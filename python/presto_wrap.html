<HTML>
<HEAD>
<TITLE>
presto_wrap.c</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>presto_wrap.c</H1>
[ Python Module : presto ]<BR>

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. class orbitparams</A>
<LI> <A HREF="#s2_">2. class psrdata</A>
<LI> <A HREF="#s3_">3. class psrparams</A>
<LI> <A HREF="#s4_">4. class DoubleArray</A>
<LI> <A HREF="#s5_">5. class infodata</A>
<LI> <A HREF="#s6_">6. class makedata</A>
<LI> <A HREF="#s7_">7. class rderivs</A>
<LI> <A HREF="#s8_">8. class fourierprops</A>
<LI> <A HREF="#s9_">9. class binaryprops</A>
</UL>

<P><TT><B></B></TT>
<BLOCKQUOTE>   tofloatvector(arr):
      Convert the vector 'arr' into a vector of single-precision floats.   
</BLOCKQUOTE>

<P><TT><B></B></TT>
<BLOCKQUOTE>   float_to_complex(array):
      Convert a 1-D Numeric float array into a 1-D
      single-precision complex array.  (i.e. assume that
      the float array really held the real and complex values
      of a complex array)                                        
</BLOCKQUOTE>

<P><TT><B></B></TT>
<BLOCKQUOTE>   complex_to_float(array):
      Convert a 1-D Numeric complex array into a 1-D
      single-precision float array holding the real and imaginary
      values in contiguous memory locations.   
</BLOCKQUOTE>

<P><TT><B>SQRT2 = 1.4142135623730950488016887242096980785696718753769</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>PI = 3.1415926535897932384626433832795028841971693993751</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>TWOPI = 6.2831853071795864769252867665590057683943387987502</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>DEGTORAD = 0.017453292519943295769236907684886127134428718885417</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>RADTODEG = 57.29577951308232087679815481410517033240547246656</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>PIBYTWO = 1.5707963267948966192313216916397514420985846996876</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>SOL = 299792458.0</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>SECPERJULYR = 31557600.0</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>SECPERDAY = 86400.0</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>ARCSEC2RAD = 4.8481368110953599358991410235794797595635330237270e-6</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>SEC2RAD = 7.2722052166430399038487115353692196393452995355905e-5</B></TT>
<BLOCKQUOTE>[ Constant: double  ]
<BR></BLOCKQUOTE>

<P><TT><B>LOWACC = LOWACC</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>HIGHACC = HIGHACC</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>CONV = CONV</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>CORR = CORR</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>INPLACE_CONV = INPLACE_CONV</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>INPLACE_CORR = INPLACE_CORR</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>FFTDK = FFTDK</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>FFTD = FFTD</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>FFTK = FFTK</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>NOFFTS = NOFFTS</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>RAW = RAW</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>PREPPED = PREPPED</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>FFT = FFT</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>SAME = SAME</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>power_arr(dft,numfreqs)</B></TT>
<BLOCKQUOTE>[ returns float * ]
<BR>   power_arr(dft, powers, numfreqs):
      Return the power spectrum of a complex FFT 'dft' in 'powers'.   
</BLOCKQUOTE>

<P><TT><B>phase_arr(dft,numfreqs)</B></TT>
<BLOCKQUOTE>[ returns float * ]
<BR>   phase_arr(dft, phases, numfreqs):
      Return the spectral phases (deg) of a complex FFT 'dft' in 'phases'.   
</BLOCKQUOTE>

<P><TT><B>dpower_arr(dft,numfreqs)</B></TT>
<BLOCKQUOTE>[ returns double * ]
<BR>   dpower_arr(dft, powers, numfreqs):
      Return the power spectrum of a complex FFT 'dft' in 'powers'.   
</BLOCKQUOTE>

<P><TT><B>dphase_arr(dft,numfreqs)</B></TT>
<BLOCKQUOTE>[ returns double * ]
<BR>   dphase_arr(dft, phases, numfreqs):
      Return the spectral phases (deg) of a complex FFT 'dft' in 'phases'.   
</BLOCKQUOTE>

<A name="s1_">
<HR><H2>1. class orbitparams</H2></A>
[ created from struct orbitparams ]<BR>
<P><TT><B>self.p</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Orbital period (s)                              
</BLOCKQUOTE>

<P><TT><B>self.e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Orbital eccentricity                            
</BLOCKQUOTE>

<P><TT><B>self.x</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Projected semi-major axis (lt-sec)              
</BLOCKQUOTE>

<P><TT><B>self.w</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Longitude of periapsis (deg)                    
</BLOCKQUOTE>

<P><TT><B>self.t</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Time since last periastron passage (s)          
</BLOCKQUOTE>

<P><TT><B>self.pd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Orbital period derivative (s/yr)                
</BLOCKQUOTE>

<P><TT><B>self.wd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Advance of longitude of periapsis (deg/yr)      
</BLOCKQUOTE>

<P><TT><B>orbitparams()</B></TT>
<BLOCKQUOTE>[ Constructor: returns orbitparams * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<A name="s2_">
<HR><H2>2. class psrdata</H2></A>
[ created from struct psrdata ]<BR>
   See the PSR database documentation for details   

<P><TT><B>self.ra2000</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ra1950</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.rae</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dec2000</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dec1950</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dece</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dmin__</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dmax__</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dist</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ldeg</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.bdeg</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pmra</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pmrae</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pmdec</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pmdece</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.posepoch</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.p</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pe</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pdot</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pdote</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.f2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.f2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.f3</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.f3e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.epoch</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dm</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.dme</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.rm</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.rme</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.we</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.w50</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.w10</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.s400</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.s600</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.s1400</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.tau</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.t408</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.distmod</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.lum</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.bsurf</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.age</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.edot</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pb</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pbe</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.a1</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.a1e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.om</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ome</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.omdot</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.omdote</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ee</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.t0</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.t0e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.gamma</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.gammae</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pbdot</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pbdote</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.si</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.sie</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.r__</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.re</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pb2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pb2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.a12</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.a12e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.om2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.om2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.omdot2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.omdot2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.e2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.e2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.t02</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.t02e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.gamma2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.gamma2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pbdot2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.pbdot2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.si2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.si2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.r2</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.r2e</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.nscode</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ndflag</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ntauflag</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ntype</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.modcode</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.limcode</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ibin</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.jname</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR></BLOCKQUOTE>

<P><TT><B>self.bname</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR></BLOCKQUOTE>

<P><TT><B>self.lcode</B></TT>
<BLOCKQUOTE>[ Member data: returns char  ]
<BR></BLOCKQUOTE>

<P><TT><B>self.ucode</B></TT>
<BLOCKQUOTE>[ Member data: returns char  ]
<BR></BLOCKQUOTE>

<P><TT><B>psrdata()</B></TT>
<BLOCKQUOTE>[ Constructor: returns psrdata * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<A name="s3_">
<HR><H2>3. class psrparams</H2></A>
[ created from struct psrparams ]<BR>
<P><TT><B>self.jname</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   The PSRs J2000 name           
</BLOCKQUOTE>

<P><TT><B>self.bname</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   The PSRs B1950 name           
</BLOCKQUOTE>

<P><TT><B>self.ntype</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Pulsar type (see below)       
</BLOCKQUOTE>

<P><TT><B>self.ra2000</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   J2000 RA                      
</BLOCKQUOTE>

<P><TT><B>self.dec2000</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   J2000 DEC                     
</BLOCKQUOTE>

<P><TT><B>self.dm</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Dispersion Measure            
</BLOCKQUOTE>

<P><TT><B>self.dist</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Adopted distance (kpc)        
</BLOCKQUOTE>

<P><TT><B>self.fwhm</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   FWHM pulse width in ms        
</BLOCKQUOTE>

<P><TT><B>self.timepoch</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   MJD epoch for timing          
</BLOCKQUOTE>

<P><TT><B>self.p</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   PSR period (s)                
</BLOCKQUOTE>

<P><TT><B>self.pd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   PSR period deriv (s/s)        
</BLOCKQUOTE>

<P><TT><B>self.pdd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Period 2nd deriv (s/s^2)      
</BLOCKQUOTE>

<P><TT><B>self.f</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   PSR frequency (hz)            
</BLOCKQUOTE>

<P><TT><B>self.fd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   PSR frequency deriv (s^-2)    
</BLOCKQUOTE>

<P><TT><B>self.fdd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Frequency 2nd deriv (s^-3)    
</BLOCKQUOTE>

<P><TT><B>self.orb</B></TT>
<BLOCKQUOTE>[ Member data: returns orbitparams * ]
<BR>                                                            
   Key to ntype:  (ntype &amp; 1)   =  Globular cluster         
                  (ntype &amp; 2)   =  In a SNR                 
                  (ntype &amp; 4)   =  Glitches                 
                  (ntype &amp; 8)   =  Binary (or more)         
                  (ntype &amp; 16)  =  Millisecond PSR          
                  (ntype &amp; 32)  =  Recycled PSR             
                  (ntype &amp; 64)  =  Has an interpulse        
                  (ntype &amp; 128) =  High-energy pulsations   
</BLOCKQUOTE>

<P><TT><B>psrparams()</B></TT>
<BLOCKQUOTE>[ Constructor: returns psrparams * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>num_psrs_in_database()</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Returns the number of entries in the database   
</BLOCKQUOTE>

<P><TT><B>get_psrdata(psr,psrname)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Read a full pulsar database entry for pulsar psrname.   
   Return the data in a psrdata structure.                 
</BLOCKQUOTE>

<P><TT><B>get_psrdata_by_num(psr,pnum)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Read a full pulsar database entry for the pulsar pnum   
   in the database.  Return the data in psrdata.           
</BLOCKQUOTE>

<P><TT><B>return_psrparams_at_epoch(psr,psrname,epoch)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Reads info from the pulsar database and converts returned values   
   to epoch 'epoch'.  Returned values go in psr (psrparams).          
   psrname is the pulsar name we are looking for (no J or B prefix)   
   epoch is the time in question in MJD.                              
   The int returned is the number of the pulsar in the database.      
   If the int = 0, then no match was found.                           
</BLOCKQUOTE>

<P><TT><B>get_psr_at_epoch(psrname,epoch,pdata,psr)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Converts info from the pulsar database to &quot;current&quot; epoch.         
   Returned values go in *psr.  The database data is in *pdata.       
   psrname is the pulsar name we are looking for (no J or B prefix)   
   epoch is the time in question in MJD.                              
   The int returned is the number of the pulsar in the database.      
   If the int = 0, then no match was found.                           
</BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. class DoubleArray</H2></A>
[ created from struct DoubleArray ]<BR>
<P><TT><B>self.dptr</B></TT>
<BLOCKQUOTE>[ Member data: returns double * ]
<BR></BLOCKQUOTE>

<P><TT><B>DoubleArray(dptr)</B></TT>
<BLOCKQUOTE>[ Constructor: returns DoubleArray * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>__getitem__(index)</B></TT>
<BLOCKQUOTE>[ Member : returns double  ]
<BR></BLOCKQUOTE>

<P><TT><B>__setitem__(index,val)</B></TT>
<BLOCKQUOTE>[ Member : returns void  ]
<BR></BLOCKQUOTE>

<A name="s5_">
<HR><H2>5. class infodata</H2></A>
[ created from struct infodata ]<BR>
<P><TT><B>self.name</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Data file name without suffix           
</BLOCKQUOTE>

<P><TT><B>self.object</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Object being observed                   
</BLOCKQUOTE>

<P><TT><B>self.ra_h</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Right ascension hours (J2000)           
</BLOCKQUOTE>

<P><TT><B>self.ra_m</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Right ascension minutes (J2000)         
</BLOCKQUOTE>

<P><TT><B>self.ra_s</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Right ascension seconds (J2000)         
</BLOCKQUOTE>

<P><TT><B>self.dec_d</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Declination degrees (J2000)             
</BLOCKQUOTE>

<P><TT><B>self.dec_m</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Declination minutes (J2000)             
</BLOCKQUOTE>

<P><TT><B>self.dec_s</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Declination seconds (J2000)             
</BLOCKQUOTE>

<P><TT><B>self.telescope</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Telescope used                          
</BLOCKQUOTE>

<P><TT><B>self.instrument</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Instrument used                         
</BLOCKQUOTE>

<P><TT><B>self.observer</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Observer[s] for the data set            
</BLOCKQUOTE>

<P><TT><B>self.N</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Number of bins in the time series       
</BLOCKQUOTE>

<P><TT><B>self.dt</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Width of each time series bin (sec)     
</BLOCKQUOTE>

<P><TT><B>self.numonoff</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Any breaks in the data?  1=yes, 0=no    
</BLOCKQUOTE>

<P><TT><B>self.onoff</B></TT>
<BLOCKQUOTE>[ Member data: returns DoubleArray * ]
<BR>   Bin number pairs where obs is &quot;on&quot;      
</BLOCKQUOTE>

<P><TT><B>self.fov</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Diameter of Beam or FOV in arcsec       
</BLOCKQUOTE>

<P><TT><B>self.mjd_i</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Epoch of observation (MJD) int part     
</BLOCKQUOTE>

<P><TT><B>self.mjd_f</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Epoch of observation (MJD) frac part    
</BLOCKQUOTE>

<P><TT><B>self.bary</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Barycentered?  1=yes, 0=no              
</BLOCKQUOTE>

<P><TT><B>self.band</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Type of observation (EM band)           
</BLOCKQUOTE>

<P><TT><B>self.dm</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Radio -- Dispersion Measure (cm-3 pc)   
</BLOCKQUOTE>

<P><TT><B>self.freq</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Radio -- Low chan central freq (Mhz)    
</BLOCKQUOTE>

<P><TT><B>self.freqband</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Radio -- Total Bandwidth (Mhz)          
</BLOCKQUOTE>

<P><TT><B>self.num_chan</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Radio -- Number Channels                
</BLOCKQUOTE>

<P><TT><B>self.chan_wid</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Radio -- Channel Bandwidth (Mhz)        
</BLOCKQUOTE>

<P><TT><B>self.filt</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   IR,Opt,UV -- Photometric Filter         
</BLOCKQUOTE>

<P><TT><B>self.wavelen</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   IR,Opt,UV -- central wavelength (nm)    
</BLOCKQUOTE>

<P><TT><B>self.waveband</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   IR,Opt,UV -- bandpass (nm)              
</BLOCKQUOTE>

<P><TT><B>self.energy</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   x-ray,gamma -- central energy (kev)     
</BLOCKQUOTE>

<P><TT><B>self.energyband</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   x-ray,gamma -- energy bandpass (kev)    
</BLOCKQUOTE>

<P><TT><B>self.analyzer</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Who analyzed the data                   
</BLOCKQUOTE>

<P><TT><B>self.notes</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Any additional notes                    
</BLOCKQUOTE>

<P><TT><B>infodata()</B></TT>
<BLOCKQUOTE>[ Constructor: returns infodata * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>readinf(data,filenm)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Read a &quot;.inf&quot; file into memory.   
</BLOCKQUOTE>

<P><TT><B>writeinf(data)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Write a &quot;.inf&quot; file to disk.   
</BLOCKQUOTE>

<A name="s6_">
<HR><H2>6. class makedata</H2></A>
[ created from struct makedata ]<BR>
<P><TT><B>self.basefilenm</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Data file name without suffix           
</BLOCKQUOTE>

<P><TT><B>self.description</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Data description                        
</BLOCKQUOTE>

<P><TT><B>self.N</B></TT>
<BLOCKQUOTE>[ Member data: returns long  ]
<BR>   Number of bins in the time series       
</BLOCKQUOTE>

<P><TT><B>self.next2_to_n</B></TT>
<BLOCKQUOTE>[ Member data: returns long  ]
<BR>   The next power-of-2 >= N                
</BLOCKQUOTE>

<P><TT><B>self.dt</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Width of each time series bin (sec)     
</BLOCKQUOTE>

<P><TT><B>self.T</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Total length of time series (sec)       
</BLOCKQUOTE>

<P><TT><B>self.ptype</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Pulsetype (Sine, Crab-like, Spike)      
</BLOCKQUOTE>

<P><TT><B>self.pnum</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   1=Sine, 2=Crab-like, 3=Spike            
</BLOCKQUOTE>

<P><TT><B>self.fwhm</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   FWHM Phase (0-1) if ptype is Spike      
</BLOCKQUOTE>

<P><TT><B>self.round</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Rounding Format (Whole, Fractional)     
</BLOCKQUOTE>

<P><TT><B>self.roundnum</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   1=Whole Numbers, 0=Fractional           
</BLOCKQUOTE>

<P><TT><B>self.f</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar frequency (hz)                   
</BLOCKQUOTE>

<P><TT><B>self.fd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar frequency deriv (hz/s)           
</BLOCKQUOTE>

<P><TT><B>self.fdd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar 2nd frequency deriv (hz/s^2)     
</BLOCKQUOTE>

<P><TT><B>self.p</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar period (s)                       
</BLOCKQUOTE>

<P><TT><B>self.pd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar period deriv (s/s)               
</BLOCKQUOTE>

<P><TT><B>self.pdd</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar 2nd period deriv (s/s^2)         
</BLOCKQUOTE>

<P><TT><B>self.r</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar FFT freq (bin)                   
</BLOCKQUOTE>

<P><TT><B>self.z</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar FFT freq deriv (bins/T)          
</BLOCKQUOTE>

<P><TT><B>self.w</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar FFT 2nd freq deriv (bins/T^2)    
</BLOCKQUOTE>

<P><TT><B>self.amp</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulse amplitude                         
</BLOCKQUOTE>

<P><TT><B>self.phs</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulse phase (deg)                       
</BLOCKQUOTE>

<P><TT><B>self.dc</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Average DC background level             
</BLOCKQUOTE>

<P><TT><B>self.binary</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Binary pulsar?  (1=Yes, 0=No)           
</BLOCKQUOTE>

<P><TT><B>self.orb</B></TT>
<BLOCKQUOTE>[ Member data: returns orbitparams * ]
<BR>   Binary pulsar data                      
</BLOCKQUOTE>

<P><TT><B>self.ampmod</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   Amplitude modulation? (1=Yes, 0=No)     
</BLOCKQUOTE>

<P><TT><B>self.ampmoda</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Amplitude modulation amplitude          
</BLOCKQUOTE>

<P><TT><B>self.ampmodf</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Amplitude modulation frequency (hz)     
</BLOCKQUOTE>

<P><TT><B>self.ampmodp</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Amplitude modulation phase (deg)        
</BLOCKQUOTE>

<P><TT><B>self.noisetype</B></TT>
<BLOCKQUOTE>[ Member data: returns char * ]
<BR>   Noise type (Standard, Other)            
</BLOCKQUOTE>

<P><TT><B>self.noise</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   1=Standard, 0=Other                     
</BLOCKQUOTE>

<P><TT><B>self.noisesig</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Noise standard deviation                
</BLOCKQUOTE>

<P><TT><B>self.numonoff</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR>   The number of onoff pairs in the data   
</BLOCKQUOTE>

<P><TT><B>self.onoff</B></TT>
<BLOCKQUOTE>[ Member data: returns DoubleArray * ]
<BR>   Bin number pairs where obs is &quot;on&quot;      
</BLOCKQUOTE>

<P><TT><B>makedata()</B></TT>
<BLOCKQUOTE>[ Constructor: returns makedata * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>read_mak_input(mdata)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Get information for makedata from stdin.        
</BLOCKQUOTE>

<P><TT><B>read_mak_file(basefilenm,mdata)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Read the data for makedata from the makefile.   
</BLOCKQUOTE>

<P><TT><B>write_mak_file(mdata)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Write the data for makedata to the makefile.    
</BLOCKQUOTE>

<A name="s7_">
<HR><H2>7. class rderivs</H2></A>
[ created from struct rderivs ]<BR>
<P><TT><B>self.pow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Power normalized with local power               
</BLOCKQUOTE>

<P><TT><B>self.phs</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Signal phase                                    
</BLOCKQUOTE>

<P><TT><B>self.dpow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   1st deriv of power wrt fourier freq             
</BLOCKQUOTE>

<P><TT><B>self.dphs</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   1st deriv of phase wrt fourier freq             
</BLOCKQUOTE>

<P><TT><B>self.d2pow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   2nd deriv of power wrt fourier freq             
</BLOCKQUOTE>

<P><TT><B>self.d2phs</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   2nd deriv of power wrt fourier freq             
</BLOCKQUOTE>

<P><TT><B>self.locpow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Local mean power level                          
</BLOCKQUOTE>

<P><TT><B>rderivs()</B></TT>
<BLOCKQUOTE>[ Constructor: returns rderivs * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<A name="s8_">
<HR><H2>8. class fourierprops</H2></A>
[ created from struct fourierprops ]<BR>
<P><TT><B>self.r</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Fourier freq at start of run                    
</BLOCKQUOTE>

<P><TT><B>self.rerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in fourier freq                           
</BLOCKQUOTE>

<P><TT><B>self.z</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Fourier freq deriv at start of run = T^2*fdot   
</BLOCKQUOTE>

<P><TT><B>self.zerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in fourier freq deriv                     
</BLOCKQUOTE>

<P><TT><B>self.w</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Fourier 2nd freq deriv = T^3*fdotdot            
</BLOCKQUOTE>

<P><TT><B>self.werr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in 2nd fourier freq deriv                 
</BLOCKQUOTE>

<P><TT><B>self.pow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Power normalized with local power               
</BLOCKQUOTE>

<P><TT><B>self.powerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in power                                  
</BLOCKQUOTE>

<P><TT><B>self.sig</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Approx. Sigma level                             
</BLOCKQUOTE>

<P><TT><B>self.rawpow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Raw signal power (unnormalized)                 
</BLOCKQUOTE>

<P><TT><B>self.phs</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Signal phase                                    
</BLOCKQUOTE>

<P><TT><B>self.phserr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in phase                                  
</BLOCKQUOTE>

<P><TT><B>self.cen</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Centroid of signal pulsations over run          
</BLOCKQUOTE>

<P><TT><B>self.cenerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in centroid                               
</BLOCKQUOTE>

<P><TT><B>self.pur</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Purity:  rms duration of signal over run        
</BLOCKQUOTE>

<P><TT><B>self.purerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in purity                                 
</BLOCKQUOTE>

<P><TT><B>self.locpow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Local mean power level                          
</BLOCKQUOTE>

<P><TT><B>fourierprops()</B></TT>
<BLOCKQUOTE>[ Constructor: returns fourierprops * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<A name="s9_">
<HR><H2>9. class binaryprops</H2></A>
[ created from struct binaryprops ]<BR>
<P><TT><B>self.ppsr</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar period (s)                              
</BLOCKQUOTE>

<P><TT><B>self.fpsr</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar freq (hz)                               
</BLOCKQUOTE>

<P><TT><B>self.rpsr</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Pulsar Fourier freq (bins)                     
</BLOCKQUOTE>

<P><TT><B>self.pbin</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Binary period (s)                              
</BLOCKQUOTE>

<P><TT><B>self.rbin</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Binary Fourier freq (bins)                     
</BLOCKQUOTE>

<P><TT><B>self.z</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Amplitude of frequency modulation              
</BLOCKQUOTE>

<P><TT><B>self.asinic</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Projected semi-major axis of orbit (lt-sec)    
</BLOCKQUOTE>

<P><TT><B>self.rdetect</B></TT>
<BLOCKQUOTE>[ Member data: returns double  ]
<BR>   Mini-FFT candidate detected freq (bins)        
</BLOCKQUOTE>

<P><TT><B>self.nfftbins</B></TT>
<BLOCKQUOTE>[ Member data: returns long  ]
<BR>   Number of FFT bins in mini-fft                 
</BLOCKQUOTE>

<P><TT><B>self.lowbin</B></TT>
<BLOCKQUOTE>[ Member data: returns long  ]
<BR>   Start bin of mini-FFT in original FFT          
</BLOCKQUOTE>

<P><TT><B>self.ppsrerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in pulsar period (s)                     
</BLOCKQUOTE>

<P><TT><B>self.fpsrerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in pulsar freq (hz)                      
</BLOCKQUOTE>

<P><TT><B>self.rpsrerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in pulsar Fourier freq (bins)            
</BLOCKQUOTE>

<P><TT><B>self.pbinerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in binary period (s)                     
</BLOCKQUOTE>

<P><TT><B>self.rbinerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in pulsar Fourier freq (bins)            
</BLOCKQUOTE>

<P><TT><B>self.zerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in freq modulation ampltude              
</BLOCKQUOTE>

<P><TT><B>self.asinicerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in a*sin(i)/c in (lt-sec)                
</BLOCKQUOTE>

<P><TT><B>self.rdetecterr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in Mini-FFT detected freq (bins)         
</BLOCKQUOTE>

<P><TT><B>self.sig</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Approx. Sigma level                            
</BLOCKQUOTE>

<P><TT><B>self.phs</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Signal phase                                   
</BLOCKQUOTE>

<P><TT><B>self.phserr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in phase                                 
</BLOCKQUOTE>

<P><TT><B>self.cen</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Centroid of signal pulsations over run         
</BLOCKQUOTE>

<P><TT><B>self.cenerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in centroid                              
</BLOCKQUOTE>

<P><TT><B>self.pur</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Purity:  rms duration of signal over run       
</BLOCKQUOTE>

<P><TT><B>self.purerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in purity                                
</BLOCKQUOTE>

<P><TT><B>self.pow</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Power normalized with Nph equivalent           
</BLOCKQUOTE>

<P><TT><B>self.powerr</B></TT>
<BLOCKQUOTE>[ Member data: returns float  ]
<BR>   Error in signal power                          
</BLOCKQUOTE>

<P><TT><B>binaryprops()</B></TT>
<BLOCKQUOTE>[ Constructor: returns binaryprops * ]
<BR></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE>[ Destructor: returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>frotate(data,numbins,bins_to_left)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Rotates a vector by bins_to_left places to the left.      
   numbins is the number of FLOATING points to move.         
</BLOCKQUOTE>

<P><TT><B>drotate(data,numbins,bins_to_left)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Rotates a vector by bins_to_left places to the left.      
   numbins is the number of DOUBLE points to move.           
</BLOCKQUOTE>

<P><TT><B>dorbint(E,Eo,t,to,numpts,dt,orb)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine integrates Keplar's Equation and returns                 
   double precision vectors of eccentric anomalys (E) and times (t)      
   for each point.  The initial value for eccentric anomaly (usually     
   determined by using keplars_equation()) goes in Eo and the initial    
   time step (in sec) goes in 'to'.  The time increment to use is dt,    
   total number of pts goes in 'numpts' and all of the various orbital   
   parameters are found in *orb.  The routine uses 4th order Runge-      
   Kutta in a dumb mode (no adaptive step-size) since all we want is     
   tabulated results with even intervals.                                
</BLOCKQUOTE>

<P><TT><B>keplars_eqn(t,p_orb,e,Eacc)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   This routine solves Keplar's Equation at a single time t (sec) and    
   returns the value of the eccentric anomaly.  The orbital period (s)   
   is in p_orb and the orbital eccentricity is in e.  Eacc is the        
   absolute accuracy in E that we want to achieve.  t is the time in     
   seconds since the last periapsis.  Uses Newton-Raphson.               
</BLOCKQUOTE>

<P><TT><B>lin_interp_E(E,time,to,dt,maxt)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Return a linearly interpolated value of E at time 'time'.    
   to is the starting time and dt is the time interval of the   
   evenly tabulated dat vector *E.                              
</BLOCKQUOTE>

<P><TT><B>E_to_phib(E,numpoints,orb)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Convert eccentric anomalies returned by dorbint into   
   Phase delays.   
</BLOCKQUOTE>

<P><TT><B>E_to_v(E,numpoints,orb)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Convert eccentric anomalies returned by dorbint into   
   Pulsar line-of-sight velocity (km/s).   
</BLOCKQUOTE>

<P><TT><B>E_to_p(E,numpoints,p_psr,orb)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Convert eccentric anomalies returned by dorbint into   
   Pulse period.   
</BLOCKQUOTE>

<P><TT><B>E_to_z(E,numpoints,p_psr,T,orb)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Convert eccentric anomalies returned by dorbint into   
   Fourier f-dot.   
</BLOCKQUOTE>

<P><TT><B>E_to_phib_BT(E,numpoints,orb)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Convert eccentric anomalys (*E) to time delays   
   using Blanford and Teukolsky Equations           
   This model is NOT currently in use.              
</BLOCKQUOTE>

<P><TT><B>r_resp_halfwidth(accuracy)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>    Return the approximate kernel half width in FFT bins required      
    to achieve a fairly high accuracy correlation based correction     
    or interpolation for a standard Fourier signal.                    
    Arguments:                                                         
      'accuracy' is either LOWACC or HIGHACC.                          
    Notes:                                                             
      The result must be multiplied by 2*'numbetween' to get the       
      length of the array required to hold such a kernel.              
</BLOCKQUOTE>

<P><TT><B>z_resp_halfwidth(z,accuracy)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>    Return the approximate kernel half width in FFT bins required      
    to achieve a fairly high accuracy correlation based correction     
    or interpolation for a Fourier signal with constant f-dot. (i.e    
    a constant frequency derivative)                                   
    Arguments:                                                         
      'z' is the Fourier Frequency derivative (# of bins the signal    
         smears over during the observation).                          
      'accuracy' is either LOWACC or HIGHACC.                          
    Notes:                                                             
      The result must be multiplied by 2*'numbetween' to get the       
      length of the array required to hold such a kernel.              
</BLOCKQUOTE>

<P><TT><B>w_resp_halfwidth(z,w,accuracy)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>    Return the approximate kernel half width in FFT bins required      
    to achieve a fairly high accuracy correlation based correction     
    or interpolation for a Fourier signal with an f-dot that (i.e      
    varies linearly in time -- a constant f-dotdot)                    
    Arguments:                                                         
      'z' is the average Fourier Frequency derivative (# of bins       
         the signal smears over during the observation).               
      'w' is the Fourier Frequency 2nd derivative (change in the       
         Fourier f-dot during the observation).                        
      'accuracy' is either LOWACC or HIGHACC.                          
    Notes:                                                             
      The result must be multiplied by 2*'numbetween' to get the       
      length of the array required to hold such a kernel.              
</BLOCKQUOTE>

<P><TT><B>bin_resp_halfwidth(ppsr,orbit)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>    Return the approximate kernel half width in FFT bins required      
    to achieve a fairly high accuracy correlation based correction     
    or interpolation for a pulsar in a binary orbit.                   
    Arguments:                                                         
      'ppsr' is the period of the pusar in seconds.                    
      'orbit' is a ptr to a orbitparams structure containing the       
         Keplarian orbital parameters of the binary system.            
    Notes:                                                             
      The result must be multiplied by 2 * 'numbetween' to get the     
      length of the array required to hold such a kernel.              
</BLOCKQUOTE>

<P><TT><B>gen_r_response(roffset,numbetween,numkern)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>    Generate a complex response function for Fourier interpolation.    
    Arguments:                                                         
      'roffset' is the offset in Fourier bins for the full response    
         (i.e. At this point, the response would equal 1.0)            
      'numbetween' is the number of points to interpolate between      
         each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins)   
      'numkern' is the number of complex points that the kernel will   
         contain.                                                      
</BLOCKQUOTE>

<P><TT><B>gen_z_response(roffset,numbetween,z,numkern)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>    Generate the response function for Fourier f-dot interpolation.    
    Arguments:                                                         
      'roffset' is the offset in Fourier bins for the full response    
         (i.e. At this point, the response would equal 1.0)            
      'numbetween' is the number of points to interpolate between      
         each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins)   
      'z' is the Fourier Frequency derivative (# of bins the signal    
         smears over during the observation).                          
      'numkern' is the number of complex points that the kernel will   
         contain.                                                      
</BLOCKQUOTE>

<P><TT><B>gen_w_response(roffset,numbetween,z,w,numkern)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>    Generate the response function for Fourier f-dot interpolation.    
    Arguments:                                                         
      'roffset' is the offset in Fourier bins for the full response    
         (i.e. At this point, the response would equal 1.0)            
      'numbetween' is the number of points to interpolate between      
         each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins)   
      'z' is the average Fourier Frequency derivative (# of bins       
         the signal smears over during the observation).               
      'w' is the Fourier Frequency 2nd derivative (change in the       
         Fourier f-dot during the observation).                        
      'numkern' is the number of complex points that the kernel will   
         contain.                                                      
</BLOCKQUOTE>

<P><TT><B>gen_bin_response(roffset,numbetween,ppsr,T,orbit,numkern)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>    Generate the Fourier response function for a sinusoidal PSR        
    signal from a binary orbit.                                        
    Arguments:                                                         
      'roffset' is the offset in Fourier bins for the full response    
         (i.e. At this point, the response would equal 1.0)            
      'numbetween' is the number of points to interpolate between      
         each standard FFT bin.  (i.e. 'numbetween' = 1 = interbins)   
      'ppsr' is the period of the pusar in seconds.                    
      'T' is the length of the observation in seconds.                 
      'orbit' is a ptr to a orbitparams structure containing the       
         Keplarian orbital parameters of the binary system.            
      'numkern' is the number of complex points that the kernel will   
         contain.                                                      
</BLOCKQUOTE>

<P><TT><B>get_numphotons(file)</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   Return the total number of photons in the FFT file        
   i.e.  it returns the value of the 0th frequency bin.      
   Arguments:                                                
     'file' is a pointer to the file you want to access.     
</BLOCKQUOTE>

<P><TT><B>get_localpower(data,numdata,r)</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   Return the local power level at specific FFT frequency.    
   Arguments:                                                 
     'data' is a pointer to a complex FFT.                    
     'numdata' is the number of complex points in 'data'.     
     'r' is the Fourier frequency in data that we want to     
        interpolate.                                          
</BLOCKQUOTE>

<P><TT><B>get_localpower3d(data,numdata,r,z,w)</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   Return the local power level around a specific FFT             
   frequency, f-dot, and f-dotdot.                                
   Arguments:                                                     
     'data' is a pointer to a complex FFT.                        
     'numdata' is the number of complex points in 'data'.         
     'r' is the Fourier frequency in data that we want to         
        interpolate.                                              
     'z' is the Fourier Frequency derivative (# of bins the       
         signal smears over during the observation).              
     'w' is the Fourier Frequency 2nd derivative (change in the   
         Fourier f-dot during the observation).                   
</BLOCKQUOTE>

<P><TT><B>get_derivs3d(data,numdata,r,z,w,localpower,result)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Return an rderives structure that contains the power,        
   phase, and their first and second derivatives at a point     
   in the F/F-dot/F-dortdot volume.                             
   Arguments:                                                   
     'data' is a pointer to a complex FFT.                      
     'numdata' is the number of complex points in 'data'.       
     'r' is the Fourier frequency in data that we want to       
        interpolate.                                            
     'z' is the Fourier Frequency derivative (# of bins the     
         signal smears over during the observation).            
     'w' is the Fourier Frequency 2nd derivative (change in     
         the Fourier f-dot during the observation).             
     'localpower' is the local power level around the signal.   
     'result' is a pointer to an rderivs structure that will    
         contain the results.                                   
</BLOCKQUOTE>

<P><TT><B>calc_props(data,r,z,w,result)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Return a fourierprops structure that contains the various    
   properties of a signal described by Middleditch, Deich,      
   and Kulkarni in _Isolated_Pulsars_, 1993, p372.              
   Arguments:                                                   
     'data' is a pointer to an rderivs structure containing     
         derivative information about the peak in question.     
     'r' is the Fourier frequency in data that we want to       
        interpolate.                                            
     'z' is the Fourier Frequency derivative (# of bins the     
         signal smears over during the observation).            
     'w' is the Fourier Frequency second derivative.            
     'result' is a pointer to an fourierprops structure that    
         will contain the results.                              
</BLOCKQUOTE>

<P><TT><B>calc_binprops(props,T,lowbin,nfftbins,result)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Return a binaryprops structure that contains the various       
   estimates of the binary pulsar system from a mini-FFT.         
   Arguments:                                                     
     'props' is a pointer to the candidate's fourierprops.        
     'T' is the total length (sec) of the original time series.   
     'lowbin' is the Fourier bin number from the original FFT     
        the lowest bin in the mini-FFT.                           
     'nfftbins' is the number of bins in the mini-FFT.            
     'absnorm' is the value of the power normalization            
        constant for this mini-FFT.                               
     'result' is the returned binaryprops structure.              
</BLOCKQUOTE>

<P><TT><B>calc_rzwerrs(props,T,result)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Calculate periods, frequencies, their derivatives          
   and their errors.                                          
   Arguments:                                                 
     'props' is a pointer to a fourierprops structure.        
     'T' is the length of the data set in sec (i.e. N*dt).    
     'result' is a pointer to the returned rzwerrs struct.    
</BLOCKQUOTE>

<P><TT><B>nice_output_1(output,val,err,len)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Generates a string in &quot;output&quot; of length len with &quot;val&quot; rounded     
     to the appropriate decimal place and the error in parenthesis    
     as in scientific journals.  The error has 1 decimal place.    
</BLOCKQUOTE>

<P><TT><B>nice_output_2(output,val,err,len)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Generates a string in &quot;output&quot; of length len with &quot;val&quot; rounded     
     to the appropriate decimal place and the error in parenthesis    
     as in scientific journals.  The error has 2 decimal places.    
</BLOCKQUOTE>

<P><TT><B>print_candidate(cand,dt,N,nph,numerrdigits)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Outputs a 2 column summary of all the properties or a fourier peak    
</BLOCKQUOTE>

<P><TT><B>print_bin_candidate(cand,numerrdigits)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Outputs a 2 column summary of all the properties or a fourier peak    
</BLOCKQUOTE>

<P><TT><B>get_rzw_cand(filenm,candnum,cand)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>    Read the rzw candidate file 'filenm' and return a          
    pointer to the fourierprops that describes it.             
</BLOCKQUOTE>

<P><TT><B>get_bin_cand(filenm,candnum,cand)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>    Read the bin candidate file 'filenm' and return a          
    pointer to the binaryprops that describes it.              
</BLOCKQUOTE>

<P><TT><B>chkfilelen(file,size)</B></TT>
<BLOCKQUOTE>[ returns unsigned long  ]
<BR>   Return the length of a file (in blocks of 'size').    
</BLOCKQUOTE>

<P><TT><B>read_fcomplex_file(file,firstpt,numpts)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>   Return an fcomplex vector with complex data taken from a file.   
   Argumants:                                                       
     'file' is a pointer to the file you want to access.            
     'firstpt' is the number of the first point to get. (0 = 1st    
         point in the file).  If < 0, the resulting array will      
         be zero padded.                                            
     'numpts' is the number of points to get from the file.         
         If the number of bins to read takes us past the end of     
         file, the returned vector will be zero padded.             
</BLOCKQUOTE>

<P><TT><B>prune_powers(arr,n,numsumpows)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Sets powers that are more than PRUNELEV standard devs above   
   the median value to the median value.  Thereby &quot;cleaning&quot;     
   the spectrum of high power signals.                           
</BLOCKQUOTE>

<P><TT><B>selectkth(k,n,arr)</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   Selects the kth largest value from the array arr   
</BLOCKQUOTE>

<P><TT><B>dms2rad(deg,min,sec)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Convert degrees, minutes and seconds into radians   
</BLOCKQUOTE>

<P><TT><B>hms2rad(hour,min,sec)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Convert hours, minutes and seconds into radians   
</BLOCKQUOTE>

<P><TT><B>sphere_ang_diff(ra1,dec1,ra2,dec2)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Return the spherical angle (radians) between two RA and DECS   
</BLOCKQUOTE>

<P><TT><B>spread_with_pad(data,numdata,result,numresult,numbetween,numpad)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Prepare the data array for correlation by spreading           
        the input data array and padding it.                     
   Arguments:                                                    
     'data' is the FFT array to be prepared                      
     'numdata' is the number of complex points in 'data'         
     'result' is the prepped data array                          
     'numresult' is the number of complex points in 'result'     
     'numbetween' is the number of interpolated pts per bin      
     'numpad' is the number of bins to use as zero padding       
</BLOCKQUOTE>

<P><TT><B>spread_no_pad(data,numdata,result,numresult,numbetween)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Prepare the data array for correlation by spreading           
        the input data array.                                    
   Arguments:                                                    
     'data' is the FFT array to be prepared                      
     'numdata' is the number of complex points in 'data'         
     'result' is the prepped data array                          
     'numresult' is the number of complex points in 'result'     
     'numbetween' is the number of interpolated pts per bin      
</BLOCKQUOTE>

<P><TT><B>paddata(data,numdata,numpad)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Pad the last 'numpad' bins of 'data' with zeros.           
   Arguments:                                                 
     'data' is the FFT array to be padded                     
     'numdata' is the number of complex points in 'data'      
     'numpad' is the number of bins to use as zero padding    
</BLOCKQUOTE>

<P><TT><B>place_complex_kernel(kernel,numkernel,result,numresult)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine places the kernel in a zero filled array   
   with half of the response at the beginning and half     
   of the response at the end of the result array.  See    
   Numerical Recipes in C 2ed, p 541 for more info.        
   Arguments:                                              
     'kernel' is a complex response function.  Bin zero    
        response is in bin numkernel/2.                    
     'numkernel' is the number of points in the kernel.    
        This should be an even number.                     
     'result' is the result array.                         
     'numresult' is the number of points in the result.    
</BLOCKQUOTE>

<P><TT><B>place_real_kernel(kernel,numkernel,result,numresult)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine places the kernel in a zero filled array   
   with half of the response at the beginning and half     
   of the response at the end of the result array.  See    
   Numerical Recipes in C 2ed, p 541 for more info.        
   Arguments:                                              
     'kernel' is a real-valued response function.  Bin     
        zero response is in bin numkernel/2.               
     'numkernel' is the number of points in the kernel.    
        This should be an even number.                     
     'result' is the result array.                         
     'numresult' is the number of points in the result.    
</BLOCKQUOTE>

<P><TT><B>chop_complex_ends(data,numdata,result,numresult,chopbins)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Chop the contaminated ends off of an array that has    
   been correlated/convolved.                             
   Arguments:                                             
     'data' is the array to chop.                         
     'numdata' is the number of points in data.           
     'result' is the resultant array.                     
     'numresult' is the number of points in the result.   
     'chopbins' is the number of bins to chop on each     
        end of the data array.                            
</BLOCKQUOTE>

<P><TT><B>chop_real_ends(data,numdata,result,numresult,chopbins)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   Chop the contaminated ends off of an array that has    
   been correlated/convolved.                             
   Arguments:                                             
     'data' is the array to chop.                         
     'numdata' is the number of points in data.           
     'result' is the resultant array.                     
     'numresult' is the number of points in the result.   
     'chopbins' is the number of bins to chop on each     
        end of the data array.                            
</BLOCKQUOTE>

<P><TT><B>complex_corr_conv(data,kernel,numdata,ffts,type)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>   Perform and return a complex correlation or convolution.         
   Arguments:                                                       
     'data' is the complex array to correlate/convolve.             
     'kernel' is the correlation/convolution kernel.                
     'numdata' is the length of 'data', 'kernel' and the result.    
     'ffts' describes how to perform the convolution/correlation.   
        'ffts' = FFTDK:  FFT both the 'data' and the 'kernel'.      
        'ffts' = FFTD:  FFT only the 'data' not the 'kernel'.       
        'ffts' = FFTK:  FFT only the 'kernel' not the 'data'.       
        'ffts' = NOFFTS:  Don't FFT the 'data' or the 'kernel'.     
     'type' is the type of operation to perform.                    
        'type' = CONV:  return a convolution in a new vector.       
        'type' = CORR:  return a correlation in a new vector.       
        'type' = INPLACE_CONV:  convolution over-writes 'data'.     
        'type' = INPLACE_CORR:  correlation over-writes 'data'.     
</BLOCKQUOTE>

<P><TT><B>real_corr_conv(data,kernel,numdata,ffts,type)</B></TT>
<BLOCKQUOTE>[ returns float * ]
<BR>   Perform and return a real-valued correlation or convolution.     
   Arguments:                                                       
     'data' is the complex array to correlate/convolve.             
     'kernel' is the correlation/convolution kernel.                
     'numdata' is the length of 'data', 'kernel' and the result.    
     'ffts' describes how to perform the convolution/correlation.   
        'ffts' = FFTDK:  FFT both the 'data' and the 'kernel'.      
        'ffts' = FFTD:  FFT only the 'data' not the 'kernel'.       
        'ffts' = FFTK:  FFT only the 'kernel' not the 'data'.       
        'ffts' = NOFFTS:  Don't FFT the 'data' or the 'kernel'.     
     'type' is the type of operation to perform.                    
        'type' = CONV:  return a convolution in a new vector.       
        'type' = CORR:  return a correlation in a new vector.       
        'type' = INPLACE_CONV:  convolution over-writes 'data'.     
        'type' = INPLACE_CORR:  correlation over-writes 'data'.     
</BLOCKQUOTE>

<P><TT><B>corr_complex(data,numdata,datainf,kern,numkern,kerninf,result,numresult,lobin,numbetween,kern_half_width,optype)</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   This routine is a general correlation or convolution routine      
   for complex data.  It can perform convolutions or correlations    
   on raw complex data, data that is prepared for a convolution/     
   correlation but not FFTd, or already FFTd data.  The kernel       
   that it uses can also be raw, prepped, or FFTd.  If you call      
   the routine multiple times with either the same kernel or data    
   array, it uses a saved version of the array from the previous     
   call to cut down on many processing steps. The return value       
   tells how many usable (i.e.  non-contaminated) points were        
   returned in the result array (the first value will be that of     
   'lobin').  This routine will _not_ perform in-place               
   correlations or convolutions (i.e. it ignores those choices       
   for 'optype').                                                    
   Arguments:                                                        
     'data' is a complex array of the data to be interpolated.       
     'numdata' is the number of complex points in 'data'.            
     'datainf' is one of the following that describes the data:      
                RAW = Normal un-altered complex data.                
                PREPPED = Data has been padded and spread based      
                          on 'kern_half_width' and 'numbetween'      
                          and is ready to be FFTd.                   
                FFT = Data has already been prepared and FFTd.       
                SAME = Data is the same as the previous call.        
                          The routine uses its saved data.           
     'kern' is the correlation kernel.                               
     'numkern' is the number of complex points in 'kern'.            
     'kerninf' is one of the same choices as 'datainf' above.        
     'result' is the resulting complex array (must already exist).   
     'numresult' is the number of complex points in 'result'.        
     'lobin' is the lowest fourier bin to convolve/correlate.        
     'numbetween' is the number of bins to spread the data points.   
     'kern_half_width' is half the width (bins) of the raw kernel.   
     'optype' is either CORR or CONV (correlation or convolution).   
   Notes:                                                            
     If either 'datainf' or 'kerninf' are of type PREPPED or FFT,    
     then the length of the FFTs used in the correlation/            
     convolution calculations will be of length 'numdata' or         
     'numkern'.  If both 'datainf' and 'kerninf' are of type         
     PREPPED or FFT then 'numdata' and 'numkern' must have the       
     same value.  In order for SAME values of 'datainf' and          
     'kerninf' to help out, the routine must be called with the      
     same values for 'kern_half_width' and 'numbetween' as well.     
</BLOCKQUOTE>

<P><TT><B>stretch_fft(data,numdata,result,numresult)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine stretches and/or interpolates an FFT of length      
   numdata.  It zeros 'result' where end-effects have occurred.     
   This routine is usually used to co-add stretched FFTs to         
   increase the signal-to-noise ratios of a detection.              
   Arguments:                                                       
     'data' is a pointer to a complex FFT.                          
     'numdata' is the number of complex points in 'data'.           
     'result' is a pointer to the complex stretched array.          
     'numresult' is the number of complex points in 'result'.       
   Notes:                                                           
     The ratio of 'numresult' to 'numdata' determines the amount    
     of stretching that will take place.  For example, if           
     'numresult' is twice 'numdata', then the data will be          
     stretched by a factor of two (i.e. interbinned).               
</BLOCKQUOTE>

<P><TT><B>corr_loc_pow(powers,numpowers)</B></TT>
<BLOCKQUOTE>[ returns float * ]
<BR>   This routine determines the local power levels for every           
   frequency in an FFT containing 'numpowers' complex frequencies.    
   It sets the areas where end-effects are a problem to the           
   local power level of the closest bin without end effect            
   problems.  It returns a vector with the local power levels.        
   Arguments:                                                         
     'powers' is a pointer to a fcomplex vector containing the FFT.   
     'numpowers' is the number of complex points in 'powers'.         
</BLOCKQUOTE>

<P><TT><B>rz_interp(data,numdata,r,z,kern_half_width)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine uses the correlation method to do a Fourier          
   complex interpolation at a single point in the f-fdot plane.      
   It does the correlations manually. (i.e. no FFTs)                 
   Arguments:                                                        
     'data' is a complex array of the data to be interpolated.       
     'numdata' is the number of complex points (bins) in data.       
     'r' is the Fourier frequency in data that we want to            
        interpolate.  This can (and should) be fractional.           
     'z' is the fdot to use (z=f-dot/T^2 (T is integration time)).   
     'kern_half_width' is the half-width of the kernel in bins.      
     'ans' is the complex answer.                                    
</BLOCKQUOTE>

<P><TT><B>max_r_arr(data,numdata,rin,derivs)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Return the Fourier frequency that maximizes the power.    
</BLOCKQUOTE>

<P><TT><B>max_rz_arr(data,numdata,rin,zin,derivs)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Return the Fourier frequency and Fourier f-dot that        
   maximizes the power.                                       
</BLOCKQUOTE>

<P><TT><B>foldfile(datafile,dt,prof,proflen,fo,fdot,fdotdot,binary,delays,orbto,orbdt,numdelays,chiarr,onoffpairs)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>fold(data,N,dt,tb,prof,proflen,fo,fdot,fdotdot,binary,delays,orbto,orbdt,numdelays,onoffpairs)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>delay_from_dm(dm,freq_emitted)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Return the delay in seconds caused by dispersion, given    
   a Dispersion Measure (dm) in cm-3 pc, and the emitted      
   frequency (freq_emitted) of the pulsar in MHz.             
</BLOCKQUOTE>

<P><TT><B>dm_from_delay(delay,freq_emitted)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Return the Dispersion Measure in cm-3 pc, that would       
   cause a pulse emitted at frequency 'freq_emitted' to be    
   delayed by 'delay' seconds.                                
</BLOCKQUOTE>

<P><TT><B>doppler(freq_observed,voverc)</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   This routine returns the frequency emitted by a pulsar   
   (in MHz) given that we observe the pulsar at frequency   
   freq_observed (MHz) while moving with radial velocity    
   (in units of v/c) of voverc wrt the pulsar.              
</BLOCKQUOTE>

<P><TT><B>search_minifft(minifft,numminifft,norm,numcands,highpows,highfreqs)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine searches a short FFT (usually produced using the     
   MiniFFT binary search method) and returns two vectors which       
   contain the highest powers found and their Fourier frequencies.   
   The routine uses interbinning to help find the highest peaks.     
   Arguments:                                                        
     'minifft' is the FFT to search (complex valued)                 
     'numminifft' is the number of complex points in 'minifft'       
     'norm' is the value to multiply each pow power by to get        
        a normalized power spectrum.                                 
     'numcands' is the length of the returned vectors.               
     'highpows' a vector containing the 'numcands' highest powers.   
     'highfreqs' a vector containing the 'numcands' frequencies      
        where 'highpows' were found.                                 
   Notes:  The returned vectors must have already been allocated.    
     The returned vectors will be sorted by decreasing power.        
</BLOCKQUOTE>

<P><TT><B>barycenter(topotimes,barytimes,voverc,N,ra,dec,obs,ephem)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   This routine uses TEMPO to correct a vector of             
   topocentric times (in *topotimes) to barycentric times     
   (in *barytimes) assuming an infinite observation           
   frequency.  The routine also returns values for the        
   radial velocity of the observation site (in units of       
   v/c) at the barycentric times.  All three vectors must     
   be initialized prior to calling.  The vector length for    
   all the vectors is 'N' points.  The RA and DEC (J2000)     
   of the observed object are passed as strings in the        
   following format: &quot;hh:mm:ss.ssss&quot; for RA and               
   &quot;dd:mm:s.ssss&quot; for DEC.  The observatory site is passed    
   as a 2 letter ITOA code.  This observatory code must be    
   found in obsys.dat (in the TEMPO paths).  The ephemeris    
   is either &quot;DE200&quot; or &quot;DE400&quot;.                              
</BLOCKQUOTE>

<P><TT><B>fftwcall(indata,nn,isign)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>tablesixstepfft(indata,nn,isign)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>realfft(data,n,isign)</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>corr_rz_plane(data,numdata,numbetween,startbin,zlo,zhi,numz,fftlen,accuracy)</B></TT>
<BLOCKQUOTE>[ returns fcomplex ** ]
<BR>   This routine uses the correlation method to do Fourier            
   complex interpolations of the f-fdot plane.                       
   Arguments:                                                        
     'data' is a complex array of the data to be interpolated.       
     'numdata' is the number of complex points (bins) in data.       
     'numbetween' is the number of points to interpolate per bin.    
     'startbin' is the first bin to use in data for interpolation.   
     'zlo' is the lowest fdot to use (z=f-dot/T^2)                   
     'zhi' is the highest fdot to use (z=f-dot/T^2)                  
     'numz' is the number of z values to use to make the plane       
     'fftlen' is the # of complex pts in kernel and result.          
     'accuracy' is either HIGHACC or LOWACC.                         
     'nextbin' will contain the bin number of the first bin not      
        interpolated in data.                                        
</BLOCKQUOTE>

<P><TT><B>corr_rz_interp(data,numdata,numbetween,startbin,z,fftlen,accuracy)</B></TT>
<BLOCKQUOTE>[ returns fcomplex * ]
<BR>   This routine uses the correlation method to do a Fourier          
   complex interpolation of a slice of the f-fdot plane.             
   Arguments:                                                        
     'data' is a complex array of the data to be interpolated.       
     'numdata' is the number of complex points (bins) in data.       
     'numbetween' is the number of points to interpolate per bin.    
     'startbin' is the first bin to use in data for interpolation.   
     'z' is the fdot to use (z=f-dot/T^2).                           
     'fftlen' is the # of complex pts in kernel and result.          
     'accuracy' is either HIGHACC or LOWACC.                         
     'nextbin' will contain the bin number of the first bin not      
        interpolated in data.                                        
</BLOCKQUOTE>


</BODY>
</HTML>
