/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.21
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#include "Python.h"

/*************************************************************** -*- c -*-
 * python/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Python_TypeRegister
#define SWIG_TypeCheck       SWIG_Python_TypeCheck
#define SWIG_TypeCast        SWIG_Python_TypeCast
#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
#define SWIG_TypeName        SWIG_Python_TypeName
#define SWIG_TypeQuery       SWIG_Python_TypeQuery
#define SWIG_TypeClientData  SWIG_Python_TypeClientData
#define SWIG_PackData        SWIG_Python_PackData 
#define SWIG_UnpackData      SWIG_Python_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

#endif

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Python_MustGetPtr(p, type, argnum, flags)

/* Python-specific SWIG API */
#define SWIG_newvarlink() \
  SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr) \
  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type) \
  SWIG_Python_NewPackedObj(ptr, sz, type)
#define SWIG_InstallConstants(d, constants) \
  SWIG_Python_InstallConstants(d, constants)

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",              /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject *zero = PyInt_FromLong(0);
    PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
    Py_DECREF(zero);
  }
  return 0;

type_error:
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME(void *)
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject *n = PyInt_FromLong(1);
        PyObject_SetAttrString(inst,(char*)"thisown",n);
        Py_DECREF(n);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_psrparams swig_types[0] 
#define  SWIGTYPE_p_orbitparams swig_types[1] 
#define  SWIGTYPE_p_binaryprops swig_types[2] 
#define  SWIGTYPE_p_double swig_types[3] 
#define  SWIGTYPE_p_makedata swig_types[4] 
#define  SWIGTYPE_p_dcomplex swig_types[5] 
#define  SWIGTYPE_p_fcomplex swig_types[6] 
#define  SWIGTYPE_p_rderivs swig_types[7] 
#define  SWIGTYPE_p_float swig_types[8] 
#define  SWIGTYPE_p_DoubleArray swig_types[9] 
#define  SWIGTYPE_p_rzwerrs swig_types[10] 
#define  SWIGTYPE_p_rawbincand swig_types[11] 
#define  SWIGTYPE_p_fourierprops swig_types[12] 
#define  SWIGTYPE_p_FILE swig_types[13] 
#define  SWIGTYPE_p_infodata swig_types[14] 
#define  SWIGTYPE_p_foldstats swig_types[15] 
#define  SWIGTYPE_p_int swig_types[16] 
static swig_type_info *swig_types[18];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _presto.so
  ------------------------------------------------*/
#define SWIG_init    init_presto

#define SWIG_name    "_presto"

#include "presto.h"


#include "arrayobject.h"

#define ISCONTIGUOUS(m) ((m)->flags & CONTIGUOUS)

#define PyArray_CONTIGUOUS(m) (ISCONTIGUOUS(m) ? Py_INCREF(m), m : \
(PyArrayObject *)(PyArray_ContiguousFromObject((PyObject *)(m), (m)->descr->type_num, 0,0)))

#ifndef _FCOMPLEX_DECLARED_
typedef struct FCOMPLEX {
    float r, i;
} fcomplex;
#define _FCOMPLEX_DECLARED_
#endif				/* _FCOMPLEX_DECLARED_ */

#ifndef _DCOMPLEX_DECLARED_
typedef struct DCOMPLEX {
    double r, i;
} dcomplex;
#define _DCOMPLEX_DECLARED_
#endif				/* _DCOMPLEX_DECLARED_ */




/* Note the following is copied and slightly modified from Nick 
   Patavalis' PPGPLOT python module.                            */

static PyObject *
arrtofloatvector (PyObject *o, float **v, int *vsz){
/* arrtofloatvector(array, pointer to data, number of points):
      Convert a 1-D Numeric array into single-precision floats.
      NOTE:  You could lose some accuracy!!!  */

    PyArrayObject *a1, *af1, *af2;
    int ownedaf1=0;
    
    /* Check if args are arrays. */
    if (!PyArray_Check(o)) {
	PyErr_SetString(PyExc_TypeError,\
			"tofloatvector() object is not an array");
	return(NULL);
    }
    a1 = (PyArrayObject *)o;

    /* Check if args are vectors. */
    if (a1->nd != 1) {
	PyErr_SetString(PyExc_TypeError,\
			"tofloatvector() object is not a vector");
	return(NULL);
    }
    
    switch (a1->descr->type_num) {
    case PyArray_FLOAT:
	af1 = a1;
	break;
    case PyArray_CHAR: 
    case PyArray_UBYTE: 
    case PyArray_SBYTE:
    case PyArray_SHORT: 
    case PyArray_INT: 
    case PyArray_LONG:
    case PyArray_DOUBLE:
	if (!(af1 = (PyArrayObject *)PyArray_Cast(a1,PyArray_FLOAT))) {
	    PyErr_SetString(PyExc_TypeError,\
			    "tofloatvector() cannot cast vector to floats");
	    return(NULL);
	}
	ownedaf1 = 1;
	break;
    default:
	PyErr_SetString(PyExc_TypeError,\
			"tofloatvector() cannot cast vector to floats");
	return(NULL);
	break;
    }
    
    af2 = af1;
    if (PyArray_As1D((PyObject **)&af2, (char **)v, vsz, 
		     PyArray_FLOAT) == -1) {
	af2 = NULL;
    }
    
    if (ownedaf1)
	Py_DECREF(af1);
    return((PyObject *)af2);
}


static PyObject* 
tofloatvector(PyObject* self, PyObject* args) {
/* tofloatvector(array):
      Convert a 1-D Numeric array into single-precision floats.
      NOTE:  You could lose some accuracy!!!  */
  PyObject *arr;
  float *data=NULL;
  int numdata=0;

  if (!PyArg_ParseTuple(args, "O", &arr))
    return NULL;
  return (PyObject *)arrtofloatvector(arr, &data, &numdata);
}

static PyObject* 
float_to_complex(PyObject* self, PyObject* args) {
/* float_to_complex(array):
      Convert a 1-D Numeric float array into a 1-D
      single-precision complex array.  (i.e. assume that
      the float array really held the real and complex values
      of a complex array)                                      */
  PyArrayObject *arr;
  float *data=NULL;
  int numdata=0;

  if (!PyArg_ParseTuple(args, "O", &arr))
    return NULL;
  /* Check that obj is really an array */
  if (!PyArray_Check(arr)) {
    PyErr_SetString(PyExc_TypeError,\
		    "float_to_complex() Argument is not an array");
    return NULL;
  }
  /* Check the type */
  if (arr->descr->type_num != PyArray_FLOAT) {
    PyErr_SetString(PyExc_TypeError,\
		    "float_to_complex() Array is not made of floats.");
    return NULL;
  }
  /* Insure that the array is really 1-D */
  if (arr->nd != 1) {
    PyErr_SetString(PyExc_TypeError,\
		    "float_to_complex() Array is not 1-D.");
    return NULL;
  }
  /* Insure that the array has an even number of points */
  if (arr->dimensions[0] & 1) {
    PyErr_SetString(PyExc_TypeError,\
		    "float_to_complex() Array needs an even number of points.");
    return NULL;
  }
  /* Perform the conversion  (NOTE:  This is probably _way_ unsafe...)*/
  arr->descr = PyArray_DescrFromType(PyArray_CFLOAT);
  arr->dimensions[0] >>= 1;
  arr->strides[0] = arr->descr->elsize;
  Py_INCREF(Py_None);
  return Py_None;
}


static PyObject* 
complex_to_float(PyObject* self, PyObject* args) {
/* complex_to_float(array):
      Convert a 1-D Numeric complex array into a 1-D
      single-precision float array holding the real and imaginary
      values in contiguous memory locations. */
  PyArrayObject *arr;
  float *data=NULL;
  int numdata=0;

  if (!PyArg_ParseTuple(args, "O", &arr))
    return NULL;
  /* Check that obj is really an array */
  if (!PyArray_Check(arr)) {
    PyErr_SetString(PyExc_TypeError,\
		    "complex_to_float() Argument is not an array");
    return NULL;
  }
  /* Check the type */
  if (arr->descr->type_num != PyArray_CFLOAT) {
    PyErr_SetString(PyExc_TypeError,\
		    "complex_to_float() Array is not made of complex #'s.");
    return NULL;
  }
  /* Insure that the array is really 1-D */
  if (arr->nd != 1) {
    PyErr_SetString(PyExc_TypeError,\
		    "complex_to_float() Array is not 1-D.");
    return NULL;
  }
  /* Perform the conversion  (NOTE:  This is probably _way_ unsafe...)*/
  arr->descr = PyArray_DescrFromType(PyArray_FLOAT);
  arr->dimensions[0] <<= 1;
  arr->strides[0] = arr->descr->elsize;
  Py_INCREF(Py_None);
  return Py_None;
}

float *power_arr(fcomplex *dft, long numfreqs){
  /* Determine the spectral powers of the Fourier amplitudes 'dft'*/
  float powargr, powargi, *powers;
  long i;

  powers = gen_fvect(numfreqs);
  for (i=0; i<numfreqs; i++)
    powers[i] = POWER(dft[i].r, dft[i].i);
  return powers;
}

float *phase_arr(fcomplex *dft, long numfreqs){
  /* Determine the spectral phases of the Fourier amplitudes 'dft'*/
  float phsargr, phsargi, phstmp, *phases;
  long i;

  phases = gen_fvect(numfreqs);
  for (i=0; i<numfreqs; i++)
    phases[i] = PHASE(dft[i].r, dft[i].i);
  return phases;
}

double *dpower_arr(dcomplex *dft,  long numfreqs){
  /* Determine the spectral powers of the Fourier amplitudes 'dft'*/
  double powargr, powargi, *powers;
  long i;

  powers = gen_dvect(numfreqs);
  for (i=0; i<numfreqs; i++)
    powers[i] = POWER(dft[i].r, dft[i].i);
  return powers;
}

double *dphase_arr(dcomplex *dft, long numfreqs){
  /* Determine the spectral phases of the Fourier amplitudes 'dft'*/
  double phsargr, phsargi, phstmp, *phases;
  long i;

  phases = gen_dvect(numfreqs);
  for (i=0; i<numfreqs; i++)
    phases[i] = PHASE(dft[i].r, dft[i].i);
  return phases;
}



typedef struct {
     double *dptr;
} DoubleArray;

DoubleArray *new_DoubleArray(double *dptr){
    DoubleArray *d = (DoubleArray *) malloc(sizeof(DoubleArray));
    d->dptr = dptr;
    return d;
  }
void delete_DoubleArray(DoubleArray *self){
    free(self);
  }
double DoubleArray___getitem__(DoubleArray *self,int index){
    return self->dptr[index];
  }
void DoubleArray___setitem__(DoubleArray *self,int index,double val){
    self->dptr[index] = val;
  }

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

#ifdef __cplusplus
extern "C" {
#endif

static long _output_arraylen = 0;
static long _output_matrixrows = 0;
static long _output_matrixcols = 0;

static PyObject *_wrap_power_arr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    long arg2 ;
    float *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:power_arr",&obj0,&obj1)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj1);
        arg2 = _output_arraylen;
    }
    result = (float *)power_arr(arg1,arg2);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_FLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_phase_arr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    long arg2 ;
    float *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:phase_arr",&obj0,&obj1)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj1);
        arg2 = _output_arraylen;
    }
    result = (float *)phase_arr(arg1,arg2);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_FLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dpower_arr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    dcomplex *arg1 = (dcomplex *) 0 ;
    long arg2 ;
    double *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:dpower_arr",&obj0,&obj1)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CDOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CDOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (dcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj1);
        arg2 = _output_arraylen;
    }
    result = (double *)dpower_arr(arg1,arg2);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dphase_arr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    dcomplex *arg1 = (dcomplex *) 0 ;
    long arg2 ;
    double *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:dphase_arr",&obj0,&obj1)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CDOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CDOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (dcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj1);
        arg2 = _output_arraylen;
    }
    result = (double *)dphase_arr(arg1,arg2);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_p_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_p_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->p = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_p_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_p_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->p);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_e_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_e_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->e = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_e_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_e_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->e);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_x_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_x_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->x = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_x_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_x_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->x);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_w_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_w_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->w = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_w_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_w_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->w);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_t_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_t_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->t = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_t_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_t_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->t);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_pd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_pd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_pd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_pd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_wd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:orbitparams_wd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->wd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_orbitparams_wd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:orbitparams_wd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->wd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_orbitparams(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_orbitparams")) goto fail;
    result = (orbitparams *)(orbitparams *) calloc(1, sizeof(orbitparams));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_orbitparams, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_orbitparams(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    orbitparams *arg1 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_orbitparams",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * orbitparams_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_orbitparams, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_DoubleArray_dptr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoubleArray *arg1 = (DoubleArray *) 0 ;
    double *arg2 = (double *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoubleArray_dptr_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoubleArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->dptr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleArray_dptr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoubleArray *arg1 = (DoubleArray *) 0 ;
    double *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoubleArray_dptr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoubleArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double *) ((arg1)->dptr);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_DoubleArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    DoubleArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_DoubleArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (DoubleArray *)new_DoubleArray(arg1);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DoubleArray, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_DoubleArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoubleArray *arg1 = (DoubleArray *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_DoubleArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoubleArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    delete_DoubleArray(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoubleArray *arg1 = (DoubleArray *) 0 ;
    int arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:DoubleArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoubleArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double)DoubleArray___getitem__(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoubleArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoubleArray *arg1 = (DoubleArray *) 0 ;
    int arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oid:DoubleArray___setitem__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoubleArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    DoubleArray___setitem__(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * DoubleArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_DoubleArray, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_infodata_ra_s_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_ra_s_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ra_s = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_ra_s_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_ra_s_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->ra_s);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dec_s_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_dec_s_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dec_s = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dec_s_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_dec_s_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dec_s);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_N_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_N_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->N = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_N_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_N_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->N);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dt_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_dt_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dt = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dt_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_dt_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dt);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_fov_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_fov_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fov = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_fov_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_fov_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fov);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_mjd_f_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_mjd_f_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mjd_f = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_mjd_f_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_mjd_f_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->mjd_f);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dm_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_dm_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dm = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dm_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_dm_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dm);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_freq_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_freq_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->freq = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_freq_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_freq_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->freq);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_freqband_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_freqband_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->freqband = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_freqband_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_freqband_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->freqband);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_chan_wid_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_chan_wid_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->chan_wid = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_chan_wid_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_chan_wid_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->chan_wid);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_wavelen_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_wavelen_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->wavelen = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_wavelen_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_wavelen_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->wavelen);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_waveband_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_waveband_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->waveband = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_waveband_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_waveband_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->waveband);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_energy_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_energy_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->energy = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_energy_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_energy_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->energy);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_energyband_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:infodata_energyband_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->energyband = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_energyband_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_energyband_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->energyband);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_onoff_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double *arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:infodata_onoff_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int ii;
        double *b = (double *) arg1->onoff;
        for (ii = 0; ii < 40; ii++) b[ii] = *((double *) arg2 + ii);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_onoff_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    double *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_onoff_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double *)(double *) ((arg1)->onoff);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_double, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_num_chan_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_num_chan_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->num_chan = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_num_chan_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_num_chan_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->num_chan);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_mjd_i_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_mjd_i_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mjd_i = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_mjd_i_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_mjd_i_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->mjd_i);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_ra_h_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_ra_h_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ra_h = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_ra_h_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_ra_h_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->ra_h);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_ra_m_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_ra_m_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ra_m = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_ra_m_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_ra_m_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->ra_m);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dec_d_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_dec_d_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dec_d = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dec_d_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_dec_d_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->dec_d);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dec_m_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_dec_m_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dec_m = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_dec_m_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_dec_m_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->dec_m);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_bary_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_bary_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->bary = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_bary_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_bary_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->bary);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_numonoff_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:infodata_numonoff_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->numonoff = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_numonoff_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_numonoff_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->numonoff);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_notes_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_notes_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->notes,arg2,500);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_notes_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_notes_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->notes);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_name_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->name,arg2,200);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->name);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_object_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_object_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->object,arg2,100);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_object_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_object_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->object);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_instrument_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_instrument_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->instrument,arg2,100);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_instrument_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_instrument_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->instrument);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_observer_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_observer_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->observer,arg2,100);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_observer_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_observer_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->observer);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_analyzer_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_analyzer_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->analyzer,arg2,100);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_analyzer_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_analyzer_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->analyzer);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_telescope_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_telescope_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->telescope,arg2,40);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_telescope_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_telescope_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->telescope);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_band_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_band_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->band,arg2,40);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_band_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_band_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->band);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_filt_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:infodata_filt_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->filt,arg2,7);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_infodata_filt_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:infodata_filt_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->filt);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_infodata(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_infodata")) goto fail;
    result = (infodata *)(infodata *) calloc(1, sizeof(infodata));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_infodata, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_infodata(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_infodata",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * infodata_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_infodata, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_readinf(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:readinf",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    readinf(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_writeinf(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    infodata *arg1 = (infodata *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:writeinf",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_infodata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    writeinf(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_basefilenm_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:makedata_basefilenm_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->basefilenm,arg2,200);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_basefilenm_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_basefilenm_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->basefilenm);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_description_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:makedata_description_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->description,arg2,200);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_description_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_description_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->description);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_N_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    long arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:makedata_N_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->N = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_N_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_N_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (long) ((arg1)->N);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_next2_to_n_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    long arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:makedata_next2_to_n_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->next2_to_n = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_next2_to_n_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_next2_to_n_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (long) ((arg1)->next2_to_n);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_dt_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_dt_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dt = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_dt_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_dt_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dt);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_T_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_T_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->T = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_T_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_T_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->T);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ptype_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:makedata_ptype_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->ptype,arg2,20);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ptype_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_ptype_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->ptype);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_pnum_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:makedata_pnum_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pnum = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_pnum_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_pnum_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->pnum);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_fwhm_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_fwhm_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fwhm = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_fwhm_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_fwhm_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fwhm);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_round_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:makedata_round_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->round,arg2,20);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_round_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_round_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->round);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_roundnum_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:makedata_roundnum_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->roundnum = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_roundnum_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_roundnum_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->roundnum);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_f_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_f_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->f = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_f_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_f_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->f);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_fd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_fd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_fd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_fd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_fdd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_fdd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fdd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_fdd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_fdd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fdd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_p_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_p_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->p = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_p_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_p_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->p);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_pd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_pd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_pd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_pd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_pdd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_pdd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pdd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_pdd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_pdd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pdd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_r_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_r_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->r = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_r_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_r_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->r);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_z_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_z_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->z = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_z_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_z_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->z);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_w_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_w_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->w = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_w_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_w_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->w);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_amp_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_amp_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->amp = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_amp_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_amp_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->amp);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_phs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_phs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->phs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_phs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_phs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->phs);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_dc_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_dc_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dc = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_dc_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_dc_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dc);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_binary_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:makedata_binary_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->binary = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_binary_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_binary_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->binary);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_orb_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    orbitparams *arg2 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:makedata_orb_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->orb = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_orb_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    orbitparams *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_orb_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (orbitparams *)& ((arg1)->orb);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_orbitparams, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmod_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:makedata_ampmod_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ampmod = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmod_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_ampmod_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->ampmod);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmoda_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_ampmoda_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ampmoda = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmoda_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_ampmoda_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->ampmoda);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmodf_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_ampmodf_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ampmodf = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmodf_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_ampmodf_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->ampmodf);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmodp_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_ampmodp_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ampmodp = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_ampmodp_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_ampmodp_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->ampmodp);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_noisetype_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:makedata_noisetype_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->noisetype,arg2,20);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_noisetype_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_noisetype_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->noisetype);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_noise_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:makedata_noise_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->noise = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_noise_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_noise_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->noise);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_noisesig_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:makedata_noisesig_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->noisesig = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_noisesig_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_noisesig_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->noisesig);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_numonoff_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:makedata_numonoff_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->numonoff = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_numonoff_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_numonoff_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->numonoff);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_onoff_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    DoubleArray *arg2 = (DoubleArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:makedata_onoff_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_DoubleArray,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    {
        arg1->onoff = arg2->dptr;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_makedata_onoff_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    DoubleArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:makedata_onoff_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (DoubleArray *) ((arg1)->onoff);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DoubleArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_makedata(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_makedata")) goto fail;
    result = (makedata *)(makedata *) calloc(1, sizeof(makedata));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_makedata, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_makedata(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_makedata",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * makedata_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_makedata, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_psrparams_jname_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:psrparams_jname_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->jname,arg2,13);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_jname_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_jname_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->jname);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_bname_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:psrparams_bname_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->bname,arg2,9);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_bname_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_bname_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->bname);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_alias_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:psrparams_alias_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        strncpy(arg1->alias,arg2,10);
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_alias_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_alias_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->alias);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_ra2000_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_ra2000_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ra2000 = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_ra2000_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_ra2000_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->ra2000);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_dec2000_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_dec2000_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dec2000 = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_dec2000_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_dec2000_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dec2000);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_dm_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_dm_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dm = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_dm_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_dm_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->dm);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_timepoch_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_timepoch_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->timepoch = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_timepoch_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_timepoch_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->timepoch);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_p_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_p_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->p = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_p_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_p_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->p);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_pd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_pd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_pd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_pd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_pdd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_pdd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pdd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_pdd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_pdd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pdd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_f_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_f_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->f = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_f_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_f_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->f);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_fd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_fd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_fd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_fd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_fdd_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:psrparams_fdd_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fdd = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_fdd_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_fdd_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fdd);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_orb_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    orbitparams *arg2 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:psrparams_orb_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->orb = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_psrparams_orb_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    orbitparams *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:psrparams_orb_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (orbitparams *)& ((arg1)->orb);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_orbitparams, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_psrparams(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_psrparams")) goto fail;
    result = (psrparams *)(psrparams *) calloc(1, sizeof(psrparams));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_psrparams, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_psrparams(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    psrparams *arg1 = (psrparams *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_psrparams",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * psrparams_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_psrparams, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_read_mak_input(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:read_mak_input",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    read_mak_input(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_mak_file(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    makedata *arg2 = (makedata *) 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO:read_mak_file",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    read_mak_file(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_write_mak_file(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    makedata *arg1 = (makedata *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:write_mak_file",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_makedata,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    write_mak_file(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_pow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_pow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_pow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_pow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->pow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_phs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_phs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->phs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_phs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_phs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->phs);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_dpow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_dpow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dpow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_dpow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_dpow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->dpow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_dphs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_dphs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->dphs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_dphs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_dphs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->dphs);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_d2pow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_d2pow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->d2pow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_d2pow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_d2pow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->d2pow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_d2phs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_d2phs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->d2phs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_d2phs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_d2phs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->d2phs);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_locpow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:rderivs_locpow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->locpow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rderivs_locpow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rderivs_locpow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->locpow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_rderivs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_rderivs")) goto fail;
    result = (rderivs *)(rderivs *) calloc(1, sizeof(rderivs));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_rderivs, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_rderivs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs *arg1 = (rderivs *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_rderivs",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * rderivs_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_rderivs, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_fourierprops_r_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:fourierprops_r_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->r = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_r_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_r_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->r);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_rerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_rerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_rerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_rerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->rerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_z_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:fourierprops_z_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->z = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_z_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_z_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->z);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_zerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_zerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->zerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_zerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_zerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->zerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_w_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:fourierprops_w_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->w = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_w_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_w_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->w);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_werr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_werr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->werr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_werr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_werr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->werr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_pow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_pow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_pow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_pow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->pow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_powerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_powerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->powerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_powerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_powerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->powerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_sig_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_sig_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->sig = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_sig_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_sig_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->sig);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_rawpow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_rawpow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rawpow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_rawpow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_rawpow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->rawpow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_phs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_phs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->phs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_phs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_phs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->phs);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_phserr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_phserr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->phserr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_phserr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_phserr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->phserr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_cen_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_cen_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->cen = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_cen_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_cen_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->cen);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_cenerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_cenerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->cenerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_cenerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_cenerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->cenerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_pur_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_pur_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pur = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_pur_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_pur_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->pur);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_purerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_purerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->purerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_purerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_purerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->purerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_locpow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:fourierprops_locpow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->locpow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fourierprops_locpow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fourierprops_locpow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->locpow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_fourierprops(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_fourierprops")) goto fail;
    result = (fourierprops *)(fourierprops *) calloc(1, sizeof(fourierprops));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_fourierprops, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_fourierprops(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_fourierprops",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * fourierprops_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_fourierprops, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_binaryprops_ppsr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_ppsr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ppsr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_ppsr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_ppsr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->ppsr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_fpsr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_fpsr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fpsr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_fpsr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_fpsr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->fpsr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rpsr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_rpsr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rpsr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rpsr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_rpsr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->rpsr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pbin_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_pbin_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pbin = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pbin_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_pbin_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pbin);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rbin_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_rbin_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rbin = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rbin_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_rbin_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->rbin);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_z_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_z_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->z = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_z_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_z_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->z);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_asinic_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_asinic_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->asinic = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_asinic_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_asinic_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->asinic);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rdetect_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:binaryprops_rdetect_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rdetect = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rdetect_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_rdetect_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->rdetect);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_nfftbins_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    long arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:binaryprops_nfftbins_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->nfftbins = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_nfftbins_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_nfftbins_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (long) ((arg1)->nfftbins);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_lowbin_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    long arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:binaryprops_lowbin_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->lowbin = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_lowbin_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_lowbin_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (long) ((arg1)->lowbin);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_ppsrerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_ppsrerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ppsrerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_ppsrerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_ppsrerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->ppsrerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_fpsrerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_fpsrerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->fpsrerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_fpsrerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_fpsrerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->fpsrerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rpsrerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_rpsrerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rpsrerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rpsrerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_rpsrerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->rpsrerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pbinerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_pbinerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pbinerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pbinerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_pbinerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->pbinerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rbinerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_rbinerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rbinerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rbinerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_rbinerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->rbinerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_zerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_zerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->zerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_zerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_zerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->zerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_asinicerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_asinicerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->asinicerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_asinicerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_asinicerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->asinicerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rdetecterr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_rdetecterr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->rdetecterr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_rdetecterr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_rdetecterr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->rdetecterr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_sig_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_sig_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->sig = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_sig_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_sig_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->sig);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_phs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_phs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->phs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_phs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_phs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->phs);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_phserr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_phserr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->phserr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_phserr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_phserr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->phserr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_cen_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_cen_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->cen = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_cen_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_cen_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->cen);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_cenerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_cenerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->cenerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_cenerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_cenerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->cenerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pur_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_pur_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pur = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pur_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_pur_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->pur);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_purerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_purerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->purerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_purerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_purerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->purerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pow_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_pow_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pow = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_pow_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_pow_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->pow);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_powerr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Of:binaryprops_powerr_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->powerr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binaryprops_powerr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:binaryprops_powerr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->powerr);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_binaryprops(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_binaryprops")) goto fail;
    result = (binaryprops *)(binaryprops *) calloc(1, sizeof(binaryprops));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_binaryprops, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_binaryprops(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_binaryprops",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * binaryprops_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_binaryprops, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_rawbincand_full_N_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_full_N_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->full_N = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_full_N_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_full_N_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->full_N);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_full_T_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_full_T_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->full_T = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_full_T_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_full_T_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->full_T);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_full_lo_r_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_full_lo_r_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->full_lo_r = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_full_lo_r_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_full_lo_r_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->full_lo_r);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_N_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_mini_N_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mini_N = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_N_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_mini_N_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->mini_N);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_r_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_mini_r_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mini_r = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_r_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_mini_r_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->mini_r);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_power_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_mini_power_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mini_power = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_power_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_mini_power_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->mini_power);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_numsum_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_mini_numsum_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mini_numsum = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_numsum_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_mini_numsum_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->mini_numsum);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_sigma_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_mini_sigma_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->mini_sigma = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_mini_sigma_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_mini_sigma_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->mini_sigma);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_psr_p_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_psr_p_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->psr_p = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_psr_p_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_psr_p_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->psr_p);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_orb_p_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:rawbincand_orb_p_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->orb_p = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rawbincand_orb_p_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:rawbincand_orb_p_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->orb_p);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_rawbincand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_rawbincand")) goto fail;
    result = (rawbincand *)(rawbincand *) calloc(1, sizeof(rawbincand));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_rawbincand, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_rawbincand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand *arg1 = (rawbincand *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_rawbincand",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * rawbincand_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_rawbincand, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_foldstats_numdata_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_numdata_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->numdata = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_numdata_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_numdata_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->numdata);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_data_avg_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_data_avg_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->data_avg = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_data_avg_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_data_avg_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->data_avg);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_data_var_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_data_var_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->data_var = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_data_var_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_data_var_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->data_var);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_numprof_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_numprof_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->numprof = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_numprof_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_numprof_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->numprof);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_prof_avg_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_prof_avg_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->prof_avg = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_prof_avg_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_prof_avg_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->prof_avg);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_prof_var_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_prof_var_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->prof_var = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_prof_var_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_prof_var_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->prof_var);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_redchi_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:foldstats_redchi_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->redchi = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldstats_redchi_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:foldstats_redchi_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->redchi);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_foldstats(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_foldstats")) goto fail;
    result = (foldstats *)(foldstats *) calloc(1, sizeof(foldstats));
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_foldstats, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_foldstats(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    foldstats *arg1 = (foldstats *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_foldstats",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    free((char *) arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * foldstats_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_foldstats, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_get_psr_at_epoch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    double arg2 ;
    psrparams *arg3 = (psrparams *) 0 ;
    int result;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sdO:get_psr_at_epoch",&arg1,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_psrparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)get_psr_at_epoch(arg1,arg2,arg3);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_int(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    int arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:read_int",&obj0,&arg2)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    result = (int)read_int(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_double(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    int arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:read_double",&obj0,&arg2)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    result = (double)read_double(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_frotate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    long arg2 ;
    float arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Olf:frotate",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    frotate(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_drotate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    long arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Old:drotate",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    drotate(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dorbint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    long arg2 ;
    double arg3 ;
    orbitparams *arg4 = (orbitparams *) 0 ;
    double *result;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"dOdO:dorbint",&arg1,&obj1,&arg3,&obj3)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj1);
        arg2 = _output_arraylen;
    }
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double *)dorbint(arg1,arg2,arg3,arg4);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_keplars_eqn(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dddd:keplars_eqn",&arg1,&arg2,&arg3,&arg4)) goto fail;
    result = (double)keplars_eqn(arg1,arg2,arg3,arg4);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_lin_interp_E(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odddd:lin_interp_E",&obj0,&arg2,&arg3,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (double)lin_interp_E(arg1,arg2,arg3,arg4,arg5);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_E_to_phib(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    long arg2 ;
    orbitparams *arg3 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OlO:E_to_phib",&obj0,&arg2,&obj2)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    E_to_phib(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_E_to_v(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    long arg2 ;
    orbitparams *arg3 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OlO:E_to_v",&obj0,&arg2,&obj2)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    E_to_v(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_E_to_p(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    long arg2 ;
    double arg3 ;
    orbitparams *arg4 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OldO:E_to_p",&obj0,&arg2,&arg3,&obj3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    E_to_p(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_E_to_z(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    long arg2 ;
    double arg3 ;
    double arg4 ;
    orbitparams *arg5 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OlddO:E_to_z",&obj0,&arg2,&arg3,&arg4,&obj4)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    E_to_z(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_E_to_phib_BT(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    long arg2 ;
    orbitparams *arg3 = (orbitparams *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OlO:E_to_phib_BT",&obj0,&arg2,&obj2)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    E_to_phib_BT(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_r_resp_halfwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:r_resp_halfwidth",&arg1)) goto fail;
    result = (int)r_resp_halfwidth((presto_interp_acc )arg1);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_z_resp_halfwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"di:z_resp_halfwidth",&arg1,&arg2)) goto fail;
    result = (int)z_resp_halfwidth(arg1,(presto_interp_acc )arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_w_resp_halfwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    int arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ddi:w_resp_halfwidth",&arg1,&arg2,&arg3)) goto fail;
    result = (int)w_resp_halfwidth(arg1,arg2,(presto_interp_acc )arg3);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_binary_velocity(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    orbitparams *arg2 = (orbitparams *) 0 ;
    double *arg3 = (double *) 0 ;
    double *arg4 = (double *) 0 ;
    double temp3 ;
    double temp4 ;
    PyObject * obj1 = 0 ;
    
    arg3 = &temp3;
    arg4 = &temp4;
    if(!PyArg_ParseTuple(args,(char *)"dO:binary_velocity",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    binary_velocity(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg3));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_bin_resp_halfwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    orbitparams *arg3 = (orbitparams *) 0 ;
    int result;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"ddO:bin_resp_halfwidth",&arg1,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)bin_resp_halfwidth(arg1,arg2,arg3);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gen_r_response(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    int arg3 ;
    fcomplex *result;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"diO:gen_r_response",&arg1,&arg2,&obj2)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj2);
        arg3 = _output_arraylen;
    }
    result = (fcomplex *)gen_r_response(arg1,arg2,arg3);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gen_z_response(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    double arg3 ;
    int arg4 ;
    fcomplex *result;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"didO:gen_z_response",&arg1,&arg2,&arg3,&obj3)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj3);
        arg4 = _output_arraylen;
    }
    result = (fcomplex *)gen_z_response(arg1,arg2,arg3,arg4);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gen_w_response(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    int arg5 ;
    fcomplex *result;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"diddO:gen_w_response",&arg1,&arg2,&arg3,&arg4,&obj4)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj4);
        arg5 = _output_arraylen;
    }
    result = (fcomplex *)gen_w_response(arg1,arg2,arg3,arg4,arg5);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_gen_bin_response(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    orbitparams *arg5 = (orbitparams *) 0 ;
    int arg6 ;
    fcomplex *result;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"diddOO:gen_bin_response",&arg1,&arg2,&arg3,&arg4,&obj4,&obj5)) goto fail;
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_orbitparams,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj5);
        arg6 = _output_arraylen;
    }
    result = (fcomplex *)gen_bin_response(arg1,arg2,arg3,arg4,arg5,arg6);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_numphotons(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:get_numphotons",&obj0)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    result = (float)get_numphotons(arg1);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_localpower(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oid:get_localpower",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (float)get_localpower(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_localpower3d(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oiddd:get_localpower3d",&obj0,&arg2,&arg3,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (float)get_localpower3d(arg1,arg2,arg3,arg4,arg5);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_derivs3d(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    float arg6 ;
    rderivs *arg7 = (rderivs *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OidddfO:get_derivs3d",&obj0,&arg2,&arg3,&arg4,&arg5,&arg6,&obj6)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj6,(void **) &arg7, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    get_derivs3d(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_calc_props(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rderivs arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    fourierprops *arg5 = (fourierprops *) 0 ;
    rderivs *argp1 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdddO:calc_props",&obj0,&arg2,&arg3,&arg4,&obj4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &argp1, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg1 = *argp1; 
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    calc_props(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_calc_binprops(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double arg2 ;
    int arg3 ;
    int arg4 ;
    binaryprops *arg5 = (binaryprops *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdiiO:calc_binprops",&obj0,&arg2,&arg3,&arg4,&obj4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    calc_binprops(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_calc_rzwerrs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double arg2 ;
    rzwerrs *arg3 = (rzwerrs *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdO:calc_rzwerrs",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_rzwerrs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    calc_rzwerrs(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_candidate_sigma(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    double arg3 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"did:candidate_sigma",&arg1,&arg2,&arg3)) goto fail;
    result = (double)candidate_sigma(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_power_for_sigma(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    int arg2 ;
    double arg3 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"did:power_for_sigma",&arg1,&arg2,&arg3)) goto fail;
    result = (double)power_for_sigma(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_chisqr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oidd:chisqr",&obj0,&arg2,&arg3,&arg4)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (double)chisqr(arg1,arg2,arg3,arg4);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_print_candidate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fourierprops *arg1 = (fourierprops *) 0 ;
    double arg2 ;
    unsigned long arg3 ;
    float arg4 ;
    int arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdOfi:print_candidate",&obj0,&arg2,&obj2,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg3 = (unsigned long) PyInt_AsLong(obj2);
    if (PyErr_Occurred()) SWIG_fail;
    print_candidate(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_print_bin_candidate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    binaryprops *arg1 = (binaryprops *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:print_bin_candidate",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    print_bin_candidate(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_rzw_cand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    fourierprops *arg2 = (fourierprops *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:read_rzw_cand",&obj0,&obj1)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)read_rzw_cand(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_bin_cand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    binaryprops *arg2 = (binaryprops *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:read_bin_cand",&obj0,&obj1)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)read_bin_cand(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_rawbin_cand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    rawbincand *arg2 = (rawbincand *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:read_rawbin_cand",&obj0,&obj1)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int)read_rawbin_cand(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_rzw_cand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int arg2 ;
    fourierprops *arg3 = (fourierprops *) 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"siO:get_rzw_cand",&arg1,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_fourierprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    get_rzw_cand(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_bin_cand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int arg2 ;
    binaryprops *arg3 = (binaryprops *) 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"siO:get_bin_cand",&arg1,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_binaryprops,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    get_bin_cand(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_get_rawbin_cand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int arg2 ;
    rawbincand *arg3 = (rawbincand *) 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"siO:get_rawbin_cand",&arg1,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    get_rawbin_cand(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_chkfilelen(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    int arg2 ;
    unsigned long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:chkfilelen",&obj0,&arg2)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    result = (unsigned long)chkfilelen(arg1,arg2);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_fcomplex_file(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    int arg2 ;
    int arg3 ;
    fcomplex *result;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:read_fcomplex_file",&obj0,&arg2,&obj2)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj2);
        arg3 = _output_arraylen;
    }
    result = (fcomplex *)read_fcomplex_file(arg1,arg2,arg3);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_read_float_file(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    int arg2 ;
    int arg3 ;
    float *result;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:read_float_file",&obj0,&arg2,&obj2)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj2);
        arg3 = _output_arraylen;
    }
    result = (float *)read_float_file(arg1,arg2,arg3);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_FLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_prune_powers(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    int arg3 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:prune_powers",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (int)prune_powers(arg1,arg2,arg3);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_median(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:median",&obj0,&arg2)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (float)median(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dms2rad(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    double arg3 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"iid:dms2rad",&arg1,&arg2,&arg3)) goto fail;
    result = (double)dms2rad(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hms2rad(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    double arg3 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"iid:hms2rad",&arg1,&arg2,&arg3)) goto fail;
    result = (double)hms2rad(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sphere_ang_diff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dddd:sphere_ang_diff",&arg1,&arg2,&arg3,&arg4)) goto fail;
    result = (double)sphere_ang_diff(arg1,arg2,arg3,arg4);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_spread_with_pad(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    fcomplex *arg3 = (fcomplex *) 0 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOiii:spread_with_pad",&obj0,&arg2,&obj2,&arg4,&arg5,&arg6)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    spread_with_pad(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_spread_no_pad(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    fcomplex *arg3 = (fcomplex *) 0 ;
    int arg4 ;
    int arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOii:spread_no_pad",&obj0,&arg2,&obj2,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    spread_no_pad(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_paddata(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:paddata",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    paddata(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_place_complex_kernel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    fcomplex *arg3 = (fcomplex *) 0 ;
    int arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOi:place_complex_kernel",&obj0,&arg2,&obj2,&arg4)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    place_complex_kernel(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_place_real_kernel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOi:place_real_kernel",&obj0,&arg2,&obj2,&arg4)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    place_real_kernel(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_chop_complex_ends(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    fcomplex *arg3 = (fcomplex *) 0 ;
    int arg4 ;
    int arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOii:chop_complex_ends",&obj0,&arg2,&obj2,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    chop_complex_ends(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_chop_real_ends(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    float *arg3 = (float *) 0 ;
    int arg4 ;
    int arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOii:chop_real_ends",&obj0,&arg2,&obj2,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    chop_real_ends(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_complex_corr_conv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    fcomplex *arg2 = (fcomplex *) 0 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    fcomplex *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOiii:complex_corr_conv",&obj0,&obj1,&arg3,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj1)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj1,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj1);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg2 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (fcomplex *)complex_corr_conv(arg1,arg2,arg3,(presto_ffts )arg4,(presto_optype )arg5);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_real_corr_conv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    float *arg2 = (float *) 0 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    float *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOiii:real_corr_conv",&obj0,&obj1,&arg3,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj1)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj1,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj1);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg2 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (float *)real_corr_conv(arg1,arg2,arg3,(presto_ffts )arg4,(presto_optype )arg5);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_FLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_corr_complex(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    int arg3 ;
    fcomplex *arg4 = (fcomplex *) 0 ;
    int arg5 ;
    int arg6 ;
    fcomplex *arg7 = (fcomplex *) 0 ;
    int arg8 ;
    int arg9 ;
    int arg10 ;
    int arg11 ;
    int arg12 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiOOiOiiiii:corr_complex",&obj0,&arg2,&arg3,&obj3,&obj4,&arg6,&obj6,&arg8,&arg9,&arg10,&arg11,&arg12)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj3)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj3,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj3);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg4 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj4);
        arg5 = _output_arraylen;
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj6)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj6,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj6);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg7 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (int)corr_complex(arg1,arg2,(presto_datainf )arg3,arg4,arg5,(presto_datainf )arg6,arg7,arg8,arg9,arg10,arg11,(presto_optype )arg12);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_stretch_fft(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    fcomplex *arg3 = (fcomplex *) 0 ;
    int arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiOi:stretch_fft",&obj0,&arg2,&obj2,&arg4)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    stretch_fft(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_corr_loc_pow(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    float *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:corr_loc_pow",&obj0,&arg2)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (float *)corr_loc_pow(arg1,arg2);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_FLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_rz_interp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    int arg5 ;
    fcomplex *arg6 = (fcomplex *) 0 ;
    fcomplex temp6 ;
    PyObject * obj0 = 0 ;
    
    {
        arg6 = &temp6;
    }
    if(!PyArg_ParseTuple(args,(char *)"Oiddi:rz_interp",&obj0,&arg2,&arg3,&arg4,&arg5)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    rz_interp(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o;
        double rl, im;
        
        rl = (double) arg6->r;
        im = (double) arg6->i;
        o = PyComplex_FromDoubles(rl, im);
        resultobj = t_output_helper(resultobj, o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_max_r_arr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    double *arg4 = (double *) 0 ;
    rderivs *arg5 = (rderivs *) 0 ;
    double result;
    double temp4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    arg4 = &temp4;
    if(!PyArg_ParseTuple(args,(char *)"OidO:max_r_arr",&obj0,&arg2,&arg3,&obj3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj3,(void **) &arg5, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double)max_r_arr(arg1,arg2,arg3,arg4,arg5);
    
    resultobj = PyFloat_FromDouble(result);
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg4));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_max_rz_arr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double *arg5 = (double *) 0 ;
    double *arg6 = (double *) 0 ;
    rderivs *arg7 = (rderivs *) 0 ;
    double result;
    double temp5 ;
    double temp6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    
    arg5 = &temp5;
    arg6 = &temp6;
    if(!PyArg_ParseTuple(args,(char *)"OiddO:max_rz_arr",&obj0,&arg2,&arg3,&arg4,&obj4)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj4,(void **) &arg7, SWIGTYPE_p_rderivs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double)max_rz_arr(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    resultobj = PyFloat_FromDouble(result);
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg6));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fold_errors(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    double arg6 ;
    double arg7 ;
    double arg8 ;
    double *arg9 = (double *) 0 ;
    double *arg10 = (double *) 0 ;
    double *arg11 = (double *) 0 ;
    double temp9 ;
    double temp10 ;
    double temp11 ;
    PyObject * obj0 = 0 ;
    
    arg9 = &temp9;
    arg10 = &temp10;
    arg11 = &temp11;
    if(!PyArg_ParseTuple(args,(char *)"Oidddddd:fold_errors",&obj0,&arg2,&arg3,&arg4,&arg5,&arg6,&arg7,&arg8)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    fold_errors(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg9));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg10));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg11));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_foldfile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) 0 ;
    double arg2 ;
    double arg3 ;
    double *arg4 = (double *) 0 ;
    int arg5 ;
    double arg6 ;
    double arg7 ;
    double arg8 ;
    double arg9 ;
    int arg10 ;
    double *arg11 = (double *) 0 ;
    double *arg12 = (double *) 0 ;
    int arg13 ;
    double *arg14 = (double *) 0 ;
    foldstats *arg15 = (foldstats *) 0 ;
    float *arg16 = (float *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj15 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OddOiddddiOOiOOO:foldfile",&obj0,&arg2,&arg3,&obj3,&arg5,&arg6,&arg7,&arg8,&arg9,&arg10,&obj10,&obj11,&arg13,&obj13,&obj14,&obj15)) goto fail;
    {
        if (!PyFile_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Need a file!");
            return NULL;
        }		
        arg1 = PyFile_AsFile(obj0);
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj3)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj3,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj3);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg4 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj10)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj10,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj10);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg11 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj11)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj11,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj11);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg12 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj13)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj13,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj13);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg14 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj14,(void **) &arg15, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj15)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj15,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj15);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg16 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (double)foldfile(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fold(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double *arg5 = (double *) 0 ;
    int arg6 ;
    double arg7 ;
    double *arg8 = (double *) 0 ;
    double *arg9 = (double *) 0 ;
    double arg10 ;
    double arg11 ;
    double arg12 ;
    int arg13 ;
    double *arg14 = (double *) 0 ;
    double *arg15 = (double *) 0 ;
    int arg16 ;
    int *arg17 = (int *) 0 ;
    foldstats *arg18 = (foldstats *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj16 = 0 ;
    PyObject * obj17 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiddOidOOdddiOOiOO:fold",&obj0,&arg2,&arg3,&arg4,&obj4,&arg6,&arg7,&obj7,&obj8,&arg10,&arg11,&arg12,&arg13,&obj13,&obj14,&arg16,&obj16,&obj17)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj4)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj4,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj4);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg5 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj7)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj7,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj7);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg8 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj8)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj8,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj8);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg9 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj13)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj13,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj13);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg14 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj14)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj14,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj14);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg15 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj16)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj16,0) != PyArray_INT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of INTEGER");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj16);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg17 = (int *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj17,(void **) &arg18, SWIGTYPE_p_foldstats,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double)fold(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_simplefold(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double *arg5 = (double *) 0 ;
    int arg6 ;
    double arg7 ;
    double arg8 ;
    double arg9 ;
    double arg10 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiddOidddd:simplefold",&obj0,&arg2,&arg3,&arg4,&obj4,&arg6,&arg7,&arg8,&arg9,&arg10)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj4)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj4,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj4);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg5 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    result = (double)simplefold(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_doppler(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:doppler",&arg1,&arg2)) goto fail;
    result = (double)doppler(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_search_minifft(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    rawbincand *arg5 = (rawbincand *) 0 ;
    int arg6 ;
    int arg7 ;
    int arg8 ;
    double arg9 ;
    double arg10 ;
    double arg11 ;
    int arg12 ;
    int arg13 ;
    PyObject * obj0 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiddOiiidddii:search_minifft",&obj0,&arg2,&arg3,&arg4,&obj4,&arg6,&arg7,&arg8,&arg9,&arg10,&arg11,&arg12,&arg13)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    search_minifft(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(presto_interptype )arg12,(presto_checkaliased )arg13);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_print_rawbincand(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    rawbincand arg1 ;
    rawbincand *argp1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:print_rawbincand",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &argp1, SWIGTYPE_p_rawbincand,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg1 = *argp1; 
    print_rawbincand(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_barycenter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double *arg1 = (double *) 0 ;
    double *arg2 = (double *) 0 ;
    double *arg3 = (double *) 0 ;
    long arg4 ;
    char *arg5 ;
    char *arg6 ;
    char *arg7 ;
    char *arg8 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOlssss:barycenter",&obj0,&obj1,&obj2,&arg4,&arg5,&arg6,&arg7,&arg8)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj1)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj1,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj1);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg2 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj2)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj2,0) != PyArray_DOUBLE) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of DOUBLE");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj2);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg3 = (double *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    barycenter(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fftwcall(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    long arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oli:fftwcall",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    fftwcall(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_tablesixstepfft(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    long arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oli:tablesixstepfft",&obj0,&arg2,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    tablesixstepfft(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_realfft(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    float *arg1 = (float *) 0 ;
    unsigned long arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:realfft",&obj0,&obj1,&arg3)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, \
            "First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_FLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of FLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (float *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    arg2 = (unsigned long) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    realfft(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_tree_max_dm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"iddd:tree_max_dm",&arg1,&arg2,&arg3,&arg4)) goto fail;
    result = (double)tree_max_dm(arg1,arg2,arg3,arg4);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smearing_from_bw(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"ddd:smearing_from_bw",&arg1,&arg2,&arg3)) goto fail;
    result = (double)smearing_from_bw(arg1,arg2,arg3);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delay_from_dm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:delay_from_dm",&arg1,&arg2)) goto fail;
    result = (double)delay_from_dm(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dm_from_delay(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:dm_from_delay",&arg1,&arg2)) goto fail;
    result = (double)dm_from_delay(arg1,arg2);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dedisp_delays(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    double *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odddd:dedisp_delays",&obj0,&arg2,&arg3,&arg4,&arg5)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj0);
        arg1 = _output_arraylen;
    }
    result = (double *)dedisp_delays(arg1,arg2,arg3,arg4,arg5);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_subband_search_delays(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    double arg6 ;
    double *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oidddd:subband_search_delays",&obj0,&arg2,&arg3,&arg4,&arg5,&arg6)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj0);
        arg1 = _output_arraylen;
    }
    result = (double *)subband_search_delays(arg1,arg2,arg3,arg4,arg5,arg6);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_subband_delays(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    double arg6 ;
    double *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOdddd:subband_delays",&arg1,&obj1,&arg3,&arg4,&arg5,&arg6)) goto fail;
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj1);
        arg2 = _output_arraylen;
    }
    result = (double *)subband_delays(arg1,arg2,arg3,arg4,arg5,arg6);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_DOUBLE, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_nice_output_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    double arg2 ;
    double arg3 ;
    int arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"sddi:nice_output_1",&arg1,&arg2,&arg3,&arg4)) goto fail;
    result = (int)nice_output_1(arg1,arg2,arg3,arg4);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_nice_output_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    double arg2 ;
    double arg3 ;
    int arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"sddi:nice_output_2",&arg1,&arg2,&arg3,&arg4)) goto fail;
    result = (int)nice_output_2(arg1,arg2,arg3,arg4);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_corr_rz_plane(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    double arg5 ;
    double arg6 ;
    int arg7 ;
    int arg8 ;
    int arg9 ;
    int *arg10 = (int *) 0 ;
    fcomplex **result;
    int temp10 ;
    PyObject * obj0 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    arg10 = &temp10;
    if(!PyArg_ParseTuple(args,(char *)"OiiiddOOi:corr_rz_plane",&obj0,&arg2,&arg3,&arg4,&arg5,&arg6,&obj6,&obj7,&arg9)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_matrixcols = PyInt_AsLong((PyObject *)obj6);
        arg7 = _output_matrixcols;
    }
    {
        _output_matrixrows = PyInt_AsLong((PyObject *)obj7);
        arg8 = _output_matrixrows;
    }
    result = (fcomplex **)corr_rz_plane(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,(presto_interp_acc )arg9,arg10);
    
    {
        PyArrayObject *arr;
        int n[2];
        
        n[0] = _output_matrixcols;
        n[1] = _output_matrixrows;
        _output_matrixrows = 0;
        _output_matrixcols = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(2, n, PyArray_CFLOAT, (char *)result[0]);
        free(result);
        if (arr == NULL) return NULL;
        arr->dimensions[1] = ((int) arg9 - arg3) * arg2 ;
        arr->strides[0] = arr->dimensions[1] * sizeof(fcomplex);
        arr->flags |= OWN_DATA;
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    {
        PyObject *o = PyInt_FromLong((long) (*arg10));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_corr_rz_interp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fcomplex *arg1 = (fcomplex *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    double arg5 ;
    int arg6 ;
    int arg7 ;
    int *arg8 = (int *) 0 ;
    fcomplex *result;
    int temp8 ;
    PyObject * obj0 = 0 ;
    PyObject * obj5 = 0 ;
    
    arg8 = &temp8;
    if(!PyArg_ParseTuple(args,(char *)"OiiidOi:corr_rz_interp",&obj0,&arg2,&arg3,&arg4,&arg5,&obj5,&arg7)) goto fail;
    {
        PyArrayObject *arr;
        
        /* Check that obj is really a 1D array of bytes */
        
        if (!PyArray_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError,"First argument is not an array");
            return NULL;
        }
        
        /* check type (could also use arr->descr->type_num) */
        
        if (PyArray_ObjectType(obj0,0) != PyArray_CFLOAT) {
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect array type: we need an array of CFLOAT");
            return NULL;
        }
        arr = PyArray_CONTIGUOUS((PyArrayObject *)obj0);
        if (arr->nd != 1) {
            /* we are really strict ! */
            PyErr_SetString(PyExc_TypeError, \
            "Incorrect number of dims: we want a 1D array");
            return NULL;
        }
        arg1 = (fcomplex *)arr->data;
        Py_DECREF(arr);  /* Release our local copy of the PyArray */
    }
    {
        _output_arraylen = PyInt_AsLong((PyObject *)obj5);
        arg6 = _output_arraylen;
    }
    result = (fcomplex *)corr_rz_interp(arg1,arg2,arg3,arg4,arg5,arg6,(presto_interp_acc )arg7,arg8);
    
    {
        PyArrayObject *arr;
        int n;
        
        n = _output_arraylen;
        _output_arraylen = 0;
        arr = (PyArrayObject *) \
        PyArray_FromDimsAndData(1, (int *)&n, PyArray_CFLOAT, (char *)result);
        if (arr == NULL) return NULL;
        arr->flags |= OWN_DATA;
        arr->dimensions[0] = ((int) arg7 - arg3) * arg2;
        arr->strides[0] = arr->dimensions[1] * sizeof(fcomplex);
        PyArray_INCREF(arr);
        resultobj = (PyObject *)arr;
    }
    {
        PyObject *o = PyInt_FromLong((long) (*arg8));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"tofloatvector", tofloatvector, METH_VARARGS },
	 { (char *)"float_to_complex", float_to_complex, METH_VARARGS },
	 { (char *)"complex_to_float", complex_to_float, METH_VARARGS },
	 { (char *)"power_arr", _wrap_power_arr, METH_VARARGS },
	 { (char *)"phase_arr", _wrap_phase_arr, METH_VARARGS },
	 { (char *)"dpower_arr", _wrap_dpower_arr, METH_VARARGS },
	 { (char *)"dphase_arr", _wrap_dphase_arr, METH_VARARGS },
	 { (char *)"orbitparams_p_set", _wrap_orbitparams_p_set, METH_VARARGS },
	 { (char *)"orbitparams_p_get", _wrap_orbitparams_p_get, METH_VARARGS },
	 { (char *)"orbitparams_e_set", _wrap_orbitparams_e_set, METH_VARARGS },
	 { (char *)"orbitparams_e_get", _wrap_orbitparams_e_get, METH_VARARGS },
	 { (char *)"orbitparams_x_set", _wrap_orbitparams_x_set, METH_VARARGS },
	 { (char *)"orbitparams_x_get", _wrap_orbitparams_x_get, METH_VARARGS },
	 { (char *)"orbitparams_w_set", _wrap_orbitparams_w_set, METH_VARARGS },
	 { (char *)"orbitparams_w_get", _wrap_orbitparams_w_get, METH_VARARGS },
	 { (char *)"orbitparams_t_set", _wrap_orbitparams_t_set, METH_VARARGS },
	 { (char *)"orbitparams_t_get", _wrap_orbitparams_t_get, METH_VARARGS },
	 { (char *)"orbitparams_pd_set", _wrap_orbitparams_pd_set, METH_VARARGS },
	 { (char *)"orbitparams_pd_get", _wrap_orbitparams_pd_get, METH_VARARGS },
	 { (char *)"orbitparams_wd_set", _wrap_orbitparams_wd_set, METH_VARARGS },
	 { (char *)"orbitparams_wd_get", _wrap_orbitparams_wd_get, METH_VARARGS },
	 { (char *)"new_orbitparams", _wrap_new_orbitparams, METH_VARARGS },
	 { (char *)"delete_orbitparams", _wrap_delete_orbitparams, METH_VARARGS },
	 { (char *)"orbitparams_swigregister", orbitparams_swigregister, METH_VARARGS },
	 { (char *)"DoubleArray_dptr_set", _wrap_DoubleArray_dptr_set, METH_VARARGS },
	 { (char *)"DoubleArray_dptr_get", _wrap_DoubleArray_dptr_get, METH_VARARGS },
	 { (char *)"new_DoubleArray", _wrap_new_DoubleArray, METH_VARARGS },
	 { (char *)"delete_DoubleArray", _wrap_delete_DoubleArray, METH_VARARGS },
	 { (char *)"DoubleArray___getitem__", _wrap_DoubleArray___getitem__, METH_VARARGS },
	 { (char *)"DoubleArray___setitem__", _wrap_DoubleArray___setitem__, METH_VARARGS },
	 { (char *)"DoubleArray_swigregister", DoubleArray_swigregister, METH_VARARGS },
	 { (char *)"infodata_ra_s_set", _wrap_infodata_ra_s_set, METH_VARARGS },
	 { (char *)"infodata_ra_s_get", _wrap_infodata_ra_s_get, METH_VARARGS },
	 { (char *)"infodata_dec_s_set", _wrap_infodata_dec_s_set, METH_VARARGS },
	 { (char *)"infodata_dec_s_get", _wrap_infodata_dec_s_get, METH_VARARGS },
	 { (char *)"infodata_N_set", _wrap_infodata_N_set, METH_VARARGS },
	 { (char *)"infodata_N_get", _wrap_infodata_N_get, METH_VARARGS },
	 { (char *)"infodata_dt_set", _wrap_infodata_dt_set, METH_VARARGS },
	 { (char *)"infodata_dt_get", _wrap_infodata_dt_get, METH_VARARGS },
	 { (char *)"infodata_fov_set", _wrap_infodata_fov_set, METH_VARARGS },
	 { (char *)"infodata_fov_get", _wrap_infodata_fov_get, METH_VARARGS },
	 { (char *)"infodata_mjd_f_set", _wrap_infodata_mjd_f_set, METH_VARARGS },
	 { (char *)"infodata_mjd_f_get", _wrap_infodata_mjd_f_get, METH_VARARGS },
	 { (char *)"infodata_dm_set", _wrap_infodata_dm_set, METH_VARARGS },
	 { (char *)"infodata_dm_get", _wrap_infodata_dm_get, METH_VARARGS },
	 { (char *)"infodata_freq_set", _wrap_infodata_freq_set, METH_VARARGS },
	 { (char *)"infodata_freq_get", _wrap_infodata_freq_get, METH_VARARGS },
	 { (char *)"infodata_freqband_set", _wrap_infodata_freqband_set, METH_VARARGS },
	 { (char *)"infodata_freqband_get", _wrap_infodata_freqband_get, METH_VARARGS },
	 { (char *)"infodata_chan_wid_set", _wrap_infodata_chan_wid_set, METH_VARARGS },
	 { (char *)"infodata_chan_wid_get", _wrap_infodata_chan_wid_get, METH_VARARGS },
	 { (char *)"infodata_wavelen_set", _wrap_infodata_wavelen_set, METH_VARARGS },
	 { (char *)"infodata_wavelen_get", _wrap_infodata_wavelen_get, METH_VARARGS },
	 { (char *)"infodata_waveband_set", _wrap_infodata_waveband_set, METH_VARARGS },
	 { (char *)"infodata_waveband_get", _wrap_infodata_waveband_get, METH_VARARGS },
	 { (char *)"infodata_energy_set", _wrap_infodata_energy_set, METH_VARARGS },
	 { (char *)"infodata_energy_get", _wrap_infodata_energy_get, METH_VARARGS },
	 { (char *)"infodata_energyband_set", _wrap_infodata_energyband_set, METH_VARARGS },
	 { (char *)"infodata_energyband_get", _wrap_infodata_energyband_get, METH_VARARGS },
	 { (char *)"infodata_onoff_set", _wrap_infodata_onoff_set, METH_VARARGS },
	 { (char *)"infodata_onoff_get", _wrap_infodata_onoff_get, METH_VARARGS },
	 { (char *)"infodata_num_chan_set", _wrap_infodata_num_chan_set, METH_VARARGS },
	 { (char *)"infodata_num_chan_get", _wrap_infodata_num_chan_get, METH_VARARGS },
	 { (char *)"infodata_mjd_i_set", _wrap_infodata_mjd_i_set, METH_VARARGS },
	 { (char *)"infodata_mjd_i_get", _wrap_infodata_mjd_i_get, METH_VARARGS },
	 { (char *)"infodata_ra_h_set", _wrap_infodata_ra_h_set, METH_VARARGS },
	 { (char *)"infodata_ra_h_get", _wrap_infodata_ra_h_get, METH_VARARGS },
	 { (char *)"infodata_ra_m_set", _wrap_infodata_ra_m_set, METH_VARARGS },
	 { (char *)"infodata_ra_m_get", _wrap_infodata_ra_m_get, METH_VARARGS },
	 { (char *)"infodata_dec_d_set", _wrap_infodata_dec_d_set, METH_VARARGS },
	 { (char *)"infodata_dec_d_get", _wrap_infodata_dec_d_get, METH_VARARGS },
	 { (char *)"infodata_dec_m_set", _wrap_infodata_dec_m_set, METH_VARARGS },
	 { (char *)"infodata_dec_m_get", _wrap_infodata_dec_m_get, METH_VARARGS },
	 { (char *)"infodata_bary_set", _wrap_infodata_bary_set, METH_VARARGS },
	 { (char *)"infodata_bary_get", _wrap_infodata_bary_get, METH_VARARGS },
	 { (char *)"infodata_numonoff_set", _wrap_infodata_numonoff_set, METH_VARARGS },
	 { (char *)"infodata_numonoff_get", _wrap_infodata_numonoff_get, METH_VARARGS },
	 { (char *)"infodata_notes_set", _wrap_infodata_notes_set, METH_VARARGS },
	 { (char *)"infodata_notes_get", _wrap_infodata_notes_get, METH_VARARGS },
	 { (char *)"infodata_name_set", _wrap_infodata_name_set, METH_VARARGS },
	 { (char *)"infodata_name_get", _wrap_infodata_name_get, METH_VARARGS },
	 { (char *)"infodata_object_set", _wrap_infodata_object_set, METH_VARARGS },
	 { (char *)"infodata_object_get", _wrap_infodata_object_get, METH_VARARGS },
	 { (char *)"infodata_instrument_set", _wrap_infodata_instrument_set, METH_VARARGS },
	 { (char *)"infodata_instrument_get", _wrap_infodata_instrument_get, METH_VARARGS },
	 { (char *)"infodata_observer_set", _wrap_infodata_observer_set, METH_VARARGS },
	 { (char *)"infodata_observer_get", _wrap_infodata_observer_get, METH_VARARGS },
	 { (char *)"infodata_analyzer_set", _wrap_infodata_analyzer_set, METH_VARARGS },
	 { (char *)"infodata_analyzer_get", _wrap_infodata_analyzer_get, METH_VARARGS },
	 { (char *)"infodata_telescope_set", _wrap_infodata_telescope_set, METH_VARARGS },
	 { (char *)"infodata_telescope_get", _wrap_infodata_telescope_get, METH_VARARGS },
	 { (char *)"infodata_band_set", _wrap_infodata_band_set, METH_VARARGS },
	 { (char *)"infodata_band_get", _wrap_infodata_band_get, METH_VARARGS },
	 { (char *)"infodata_filt_set", _wrap_infodata_filt_set, METH_VARARGS },
	 { (char *)"infodata_filt_get", _wrap_infodata_filt_get, METH_VARARGS },
	 { (char *)"new_infodata", _wrap_new_infodata, METH_VARARGS },
	 { (char *)"delete_infodata", _wrap_delete_infodata, METH_VARARGS },
	 { (char *)"infodata_swigregister", infodata_swigregister, METH_VARARGS },
	 { (char *)"readinf", _wrap_readinf, METH_VARARGS },
	 { (char *)"writeinf", _wrap_writeinf, METH_VARARGS },
	 { (char *)"makedata_basefilenm_set", _wrap_makedata_basefilenm_set, METH_VARARGS },
	 { (char *)"makedata_basefilenm_get", _wrap_makedata_basefilenm_get, METH_VARARGS },
	 { (char *)"makedata_description_set", _wrap_makedata_description_set, METH_VARARGS },
	 { (char *)"makedata_description_get", _wrap_makedata_description_get, METH_VARARGS },
	 { (char *)"makedata_N_set", _wrap_makedata_N_set, METH_VARARGS },
	 { (char *)"makedata_N_get", _wrap_makedata_N_get, METH_VARARGS },
	 { (char *)"makedata_next2_to_n_set", _wrap_makedata_next2_to_n_set, METH_VARARGS },
	 { (char *)"makedata_next2_to_n_get", _wrap_makedata_next2_to_n_get, METH_VARARGS },
	 { (char *)"makedata_dt_set", _wrap_makedata_dt_set, METH_VARARGS },
	 { (char *)"makedata_dt_get", _wrap_makedata_dt_get, METH_VARARGS },
	 { (char *)"makedata_T_set", _wrap_makedata_T_set, METH_VARARGS },
	 { (char *)"makedata_T_get", _wrap_makedata_T_get, METH_VARARGS },
	 { (char *)"makedata_ptype_set", _wrap_makedata_ptype_set, METH_VARARGS },
	 { (char *)"makedata_ptype_get", _wrap_makedata_ptype_get, METH_VARARGS },
	 { (char *)"makedata_pnum_set", _wrap_makedata_pnum_set, METH_VARARGS },
	 { (char *)"makedata_pnum_get", _wrap_makedata_pnum_get, METH_VARARGS },
	 { (char *)"makedata_fwhm_set", _wrap_makedata_fwhm_set, METH_VARARGS },
	 { (char *)"makedata_fwhm_get", _wrap_makedata_fwhm_get, METH_VARARGS },
	 { (char *)"makedata_round_set", _wrap_makedata_round_set, METH_VARARGS },
	 { (char *)"makedata_round_get", _wrap_makedata_round_get, METH_VARARGS },
	 { (char *)"makedata_roundnum_set", _wrap_makedata_roundnum_set, METH_VARARGS },
	 { (char *)"makedata_roundnum_get", _wrap_makedata_roundnum_get, METH_VARARGS },
	 { (char *)"makedata_f_set", _wrap_makedata_f_set, METH_VARARGS },
	 { (char *)"makedata_f_get", _wrap_makedata_f_get, METH_VARARGS },
	 { (char *)"makedata_fd_set", _wrap_makedata_fd_set, METH_VARARGS },
	 { (char *)"makedata_fd_get", _wrap_makedata_fd_get, METH_VARARGS },
	 { (char *)"makedata_fdd_set", _wrap_makedata_fdd_set, METH_VARARGS },
	 { (char *)"makedata_fdd_get", _wrap_makedata_fdd_get, METH_VARARGS },
	 { (char *)"makedata_p_set", _wrap_makedata_p_set, METH_VARARGS },
	 { (char *)"makedata_p_get", _wrap_makedata_p_get, METH_VARARGS },
	 { (char *)"makedata_pd_set", _wrap_makedata_pd_set, METH_VARARGS },
	 { (char *)"makedata_pd_get", _wrap_makedata_pd_get, METH_VARARGS },
	 { (char *)"makedata_pdd_set", _wrap_makedata_pdd_set, METH_VARARGS },
	 { (char *)"makedata_pdd_get", _wrap_makedata_pdd_get, METH_VARARGS },
	 { (char *)"makedata_r_set", _wrap_makedata_r_set, METH_VARARGS },
	 { (char *)"makedata_r_get", _wrap_makedata_r_get, METH_VARARGS },
	 { (char *)"makedata_z_set", _wrap_makedata_z_set, METH_VARARGS },
	 { (char *)"makedata_z_get", _wrap_makedata_z_get, METH_VARARGS },
	 { (char *)"makedata_w_set", _wrap_makedata_w_set, METH_VARARGS },
	 { (char *)"makedata_w_get", _wrap_makedata_w_get, METH_VARARGS },
	 { (char *)"makedata_amp_set", _wrap_makedata_amp_set, METH_VARARGS },
	 { (char *)"makedata_amp_get", _wrap_makedata_amp_get, METH_VARARGS },
	 { (char *)"makedata_phs_set", _wrap_makedata_phs_set, METH_VARARGS },
	 { (char *)"makedata_phs_get", _wrap_makedata_phs_get, METH_VARARGS },
	 { (char *)"makedata_dc_set", _wrap_makedata_dc_set, METH_VARARGS },
	 { (char *)"makedata_dc_get", _wrap_makedata_dc_get, METH_VARARGS },
	 { (char *)"makedata_binary_set", _wrap_makedata_binary_set, METH_VARARGS },
	 { (char *)"makedata_binary_get", _wrap_makedata_binary_get, METH_VARARGS },
	 { (char *)"makedata_orb_set", _wrap_makedata_orb_set, METH_VARARGS },
	 { (char *)"makedata_orb_get", _wrap_makedata_orb_get, METH_VARARGS },
	 { (char *)"makedata_ampmod_set", _wrap_makedata_ampmod_set, METH_VARARGS },
	 { (char *)"makedata_ampmod_get", _wrap_makedata_ampmod_get, METH_VARARGS },
	 { (char *)"makedata_ampmoda_set", _wrap_makedata_ampmoda_set, METH_VARARGS },
	 { (char *)"makedata_ampmoda_get", _wrap_makedata_ampmoda_get, METH_VARARGS },
	 { (char *)"makedata_ampmodf_set", _wrap_makedata_ampmodf_set, METH_VARARGS },
	 { (char *)"makedata_ampmodf_get", _wrap_makedata_ampmodf_get, METH_VARARGS },
	 { (char *)"makedata_ampmodp_set", _wrap_makedata_ampmodp_set, METH_VARARGS },
	 { (char *)"makedata_ampmodp_get", _wrap_makedata_ampmodp_get, METH_VARARGS },
	 { (char *)"makedata_noisetype_set", _wrap_makedata_noisetype_set, METH_VARARGS },
	 { (char *)"makedata_noisetype_get", _wrap_makedata_noisetype_get, METH_VARARGS },
	 { (char *)"makedata_noise_set", _wrap_makedata_noise_set, METH_VARARGS },
	 { (char *)"makedata_noise_get", _wrap_makedata_noise_get, METH_VARARGS },
	 { (char *)"makedata_noisesig_set", _wrap_makedata_noisesig_set, METH_VARARGS },
	 { (char *)"makedata_noisesig_get", _wrap_makedata_noisesig_get, METH_VARARGS },
	 { (char *)"makedata_numonoff_set", _wrap_makedata_numonoff_set, METH_VARARGS },
	 { (char *)"makedata_numonoff_get", _wrap_makedata_numonoff_get, METH_VARARGS },
	 { (char *)"makedata_onoff_set", _wrap_makedata_onoff_set, METH_VARARGS },
	 { (char *)"makedata_onoff_get", _wrap_makedata_onoff_get, METH_VARARGS },
	 { (char *)"new_makedata", _wrap_new_makedata, METH_VARARGS },
	 { (char *)"delete_makedata", _wrap_delete_makedata, METH_VARARGS },
	 { (char *)"makedata_swigregister", makedata_swigregister, METH_VARARGS },
	 { (char *)"psrparams_jname_set", _wrap_psrparams_jname_set, METH_VARARGS },
	 { (char *)"psrparams_jname_get", _wrap_psrparams_jname_get, METH_VARARGS },
	 { (char *)"psrparams_bname_set", _wrap_psrparams_bname_set, METH_VARARGS },
	 { (char *)"psrparams_bname_get", _wrap_psrparams_bname_get, METH_VARARGS },
	 { (char *)"psrparams_alias_set", _wrap_psrparams_alias_set, METH_VARARGS },
	 { (char *)"psrparams_alias_get", _wrap_psrparams_alias_get, METH_VARARGS },
	 { (char *)"psrparams_ra2000_set", _wrap_psrparams_ra2000_set, METH_VARARGS },
	 { (char *)"psrparams_ra2000_get", _wrap_psrparams_ra2000_get, METH_VARARGS },
	 { (char *)"psrparams_dec2000_set", _wrap_psrparams_dec2000_set, METH_VARARGS },
	 { (char *)"psrparams_dec2000_get", _wrap_psrparams_dec2000_get, METH_VARARGS },
	 { (char *)"psrparams_dm_set", _wrap_psrparams_dm_set, METH_VARARGS },
	 { (char *)"psrparams_dm_get", _wrap_psrparams_dm_get, METH_VARARGS },
	 { (char *)"psrparams_timepoch_set", _wrap_psrparams_timepoch_set, METH_VARARGS },
	 { (char *)"psrparams_timepoch_get", _wrap_psrparams_timepoch_get, METH_VARARGS },
	 { (char *)"psrparams_p_set", _wrap_psrparams_p_set, METH_VARARGS },
	 { (char *)"psrparams_p_get", _wrap_psrparams_p_get, METH_VARARGS },
	 { (char *)"psrparams_pd_set", _wrap_psrparams_pd_set, METH_VARARGS },
	 { (char *)"psrparams_pd_get", _wrap_psrparams_pd_get, METH_VARARGS },
	 { (char *)"psrparams_pdd_set", _wrap_psrparams_pdd_set, METH_VARARGS },
	 { (char *)"psrparams_pdd_get", _wrap_psrparams_pdd_get, METH_VARARGS },
	 { (char *)"psrparams_f_set", _wrap_psrparams_f_set, METH_VARARGS },
	 { (char *)"psrparams_f_get", _wrap_psrparams_f_get, METH_VARARGS },
	 { (char *)"psrparams_fd_set", _wrap_psrparams_fd_set, METH_VARARGS },
	 { (char *)"psrparams_fd_get", _wrap_psrparams_fd_get, METH_VARARGS },
	 { (char *)"psrparams_fdd_set", _wrap_psrparams_fdd_set, METH_VARARGS },
	 { (char *)"psrparams_fdd_get", _wrap_psrparams_fdd_get, METH_VARARGS },
	 { (char *)"psrparams_orb_set", _wrap_psrparams_orb_set, METH_VARARGS },
	 { (char *)"psrparams_orb_get", _wrap_psrparams_orb_get, METH_VARARGS },
	 { (char *)"new_psrparams", _wrap_new_psrparams, METH_VARARGS },
	 { (char *)"delete_psrparams", _wrap_delete_psrparams, METH_VARARGS },
	 { (char *)"psrparams_swigregister", psrparams_swigregister, METH_VARARGS },
	 { (char *)"read_mak_input", _wrap_read_mak_input, METH_VARARGS },
	 { (char *)"read_mak_file", _wrap_read_mak_file, METH_VARARGS },
	 { (char *)"write_mak_file", _wrap_write_mak_file, METH_VARARGS },
	 { (char *)"rderivs_pow_set", _wrap_rderivs_pow_set, METH_VARARGS },
	 { (char *)"rderivs_pow_get", _wrap_rderivs_pow_get, METH_VARARGS },
	 { (char *)"rderivs_phs_set", _wrap_rderivs_phs_set, METH_VARARGS },
	 { (char *)"rderivs_phs_get", _wrap_rderivs_phs_get, METH_VARARGS },
	 { (char *)"rderivs_dpow_set", _wrap_rderivs_dpow_set, METH_VARARGS },
	 { (char *)"rderivs_dpow_get", _wrap_rderivs_dpow_get, METH_VARARGS },
	 { (char *)"rderivs_dphs_set", _wrap_rderivs_dphs_set, METH_VARARGS },
	 { (char *)"rderivs_dphs_get", _wrap_rderivs_dphs_get, METH_VARARGS },
	 { (char *)"rderivs_d2pow_set", _wrap_rderivs_d2pow_set, METH_VARARGS },
	 { (char *)"rderivs_d2pow_get", _wrap_rderivs_d2pow_get, METH_VARARGS },
	 { (char *)"rderivs_d2phs_set", _wrap_rderivs_d2phs_set, METH_VARARGS },
	 { (char *)"rderivs_d2phs_get", _wrap_rderivs_d2phs_get, METH_VARARGS },
	 { (char *)"rderivs_locpow_set", _wrap_rderivs_locpow_set, METH_VARARGS },
	 { (char *)"rderivs_locpow_get", _wrap_rderivs_locpow_get, METH_VARARGS },
	 { (char *)"new_rderivs", _wrap_new_rderivs, METH_VARARGS },
	 { (char *)"delete_rderivs", _wrap_delete_rderivs, METH_VARARGS },
	 { (char *)"rderivs_swigregister", rderivs_swigregister, METH_VARARGS },
	 { (char *)"fourierprops_r_set", _wrap_fourierprops_r_set, METH_VARARGS },
	 { (char *)"fourierprops_r_get", _wrap_fourierprops_r_get, METH_VARARGS },
	 { (char *)"fourierprops_rerr_set", _wrap_fourierprops_rerr_set, METH_VARARGS },
	 { (char *)"fourierprops_rerr_get", _wrap_fourierprops_rerr_get, METH_VARARGS },
	 { (char *)"fourierprops_z_set", _wrap_fourierprops_z_set, METH_VARARGS },
	 { (char *)"fourierprops_z_get", _wrap_fourierprops_z_get, METH_VARARGS },
	 { (char *)"fourierprops_zerr_set", _wrap_fourierprops_zerr_set, METH_VARARGS },
	 { (char *)"fourierprops_zerr_get", _wrap_fourierprops_zerr_get, METH_VARARGS },
	 { (char *)"fourierprops_w_set", _wrap_fourierprops_w_set, METH_VARARGS },
	 { (char *)"fourierprops_w_get", _wrap_fourierprops_w_get, METH_VARARGS },
	 { (char *)"fourierprops_werr_set", _wrap_fourierprops_werr_set, METH_VARARGS },
	 { (char *)"fourierprops_werr_get", _wrap_fourierprops_werr_get, METH_VARARGS },
	 { (char *)"fourierprops_pow_set", _wrap_fourierprops_pow_set, METH_VARARGS },
	 { (char *)"fourierprops_pow_get", _wrap_fourierprops_pow_get, METH_VARARGS },
	 { (char *)"fourierprops_powerr_set", _wrap_fourierprops_powerr_set, METH_VARARGS },
	 { (char *)"fourierprops_powerr_get", _wrap_fourierprops_powerr_get, METH_VARARGS },
	 { (char *)"fourierprops_sig_set", _wrap_fourierprops_sig_set, METH_VARARGS },
	 { (char *)"fourierprops_sig_get", _wrap_fourierprops_sig_get, METH_VARARGS },
	 { (char *)"fourierprops_rawpow_set", _wrap_fourierprops_rawpow_set, METH_VARARGS },
	 { (char *)"fourierprops_rawpow_get", _wrap_fourierprops_rawpow_get, METH_VARARGS },
	 { (char *)"fourierprops_phs_set", _wrap_fourierprops_phs_set, METH_VARARGS },
	 { (char *)"fourierprops_phs_get", _wrap_fourierprops_phs_get, METH_VARARGS },
	 { (char *)"fourierprops_phserr_set", _wrap_fourierprops_phserr_set, METH_VARARGS },
	 { (char *)"fourierprops_phserr_get", _wrap_fourierprops_phserr_get, METH_VARARGS },
	 { (char *)"fourierprops_cen_set", _wrap_fourierprops_cen_set, METH_VARARGS },
	 { (char *)"fourierprops_cen_get", _wrap_fourierprops_cen_get, METH_VARARGS },
	 { (char *)"fourierprops_cenerr_set", _wrap_fourierprops_cenerr_set, METH_VARARGS },
	 { (char *)"fourierprops_cenerr_get", _wrap_fourierprops_cenerr_get, METH_VARARGS },
	 { (char *)"fourierprops_pur_set", _wrap_fourierprops_pur_set, METH_VARARGS },
	 { (char *)"fourierprops_pur_get", _wrap_fourierprops_pur_get, METH_VARARGS },
	 { (char *)"fourierprops_purerr_set", _wrap_fourierprops_purerr_set, METH_VARARGS },
	 { (char *)"fourierprops_purerr_get", _wrap_fourierprops_purerr_get, METH_VARARGS },
	 { (char *)"fourierprops_locpow_set", _wrap_fourierprops_locpow_set, METH_VARARGS },
	 { (char *)"fourierprops_locpow_get", _wrap_fourierprops_locpow_get, METH_VARARGS },
	 { (char *)"new_fourierprops", _wrap_new_fourierprops, METH_VARARGS },
	 { (char *)"delete_fourierprops", _wrap_delete_fourierprops, METH_VARARGS },
	 { (char *)"fourierprops_swigregister", fourierprops_swigregister, METH_VARARGS },
	 { (char *)"binaryprops_ppsr_set", _wrap_binaryprops_ppsr_set, METH_VARARGS },
	 { (char *)"binaryprops_ppsr_get", _wrap_binaryprops_ppsr_get, METH_VARARGS },
	 { (char *)"binaryprops_fpsr_set", _wrap_binaryprops_fpsr_set, METH_VARARGS },
	 { (char *)"binaryprops_fpsr_get", _wrap_binaryprops_fpsr_get, METH_VARARGS },
	 { (char *)"binaryprops_rpsr_set", _wrap_binaryprops_rpsr_set, METH_VARARGS },
	 { (char *)"binaryprops_rpsr_get", _wrap_binaryprops_rpsr_get, METH_VARARGS },
	 { (char *)"binaryprops_pbin_set", _wrap_binaryprops_pbin_set, METH_VARARGS },
	 { (char *)"binaryprops_pbin_get", _wrap_binaryprops_pbin_get, METH_VARARGS },
	 { (char *)"binaryprops_rbin_set", _wrap_binaryprops_rbin_set, METH_VARARGS },
	 { (char *)"binaryprops_rbin_get", _wrap_binaryprops_rbin_get, METH_VARARGS },
	 { (char *)"binaryprops_z_set", _wrap_binaryprops_z_set, METH_VARARGS },
	 { (char *)"binaryprops_z_get", _wrap_binaryprops_z_get, METH_VARARGS },
	 { (char *)"binaryprops_asinic_set", _wrap_binaryprops_asinic_set, METH_VARARGS },
	 { (char *)"binaryprops_asinic_get", _wrap_binaryprops_asinic_get, METH_VARARGS },
	 { (char *)"binaryprops_rdetect_set", _wrap_binaryprops_rdetect_set, METH_VARARGS },
	 { (char *)"binaryprops_rdetect_get", _wrap_binaryprops_rdetect_get, METH_VARARGS },
	 { (char *)"binaryprops_nfftbins_set", _wrap_binaryprops_nfftbins_set, METH_VARARGS },
	 { (char *)"binaryprops_nfftbins_get", _wrap_binaryprops_nfftbins_get, METH_VARARGS },
	 { (char *)"binaryprops_lowbin_set", _wrap_binaryprops_lowbin_set, METH_VARARGS },
	 { (char *)"binaryprops_lowbin_get", _wrap_binaryprops_lowbin_get, METH_VARARGS },
	 { (char *)"binaryprops_ppsrerr_set", _wrap_binaryprops_ppsrerr_set, METH_VARARGS },
	 { (char *)"binaryprops_ppsrerr_get", _wrap_binaryprops_ppsrerr_get, METH_VARARGS },
	 { (char *)"binaryprops_fpsrerr_set", _wrap_binaryprops_fpsrerr_set, METH_VARARGS },
	 { (char *)"binaryprops_fpsrerr_get", _wrap_binaryprops_fpsrerr_get, METH_VARARGS },
	 { (char *)"binaryprops_rpsrerr_set", _wrap_binaryprops_rpsrerr_set, METH_VARARGS },
	 { (char *)"binaryprops_rpsrerr_get", _wrap_binaryprops_rpsrerr_get, METH_VARARGS },
	 { (char *)"binaryprops_pbinerr_set", _wrap_binaryprops_pbinerr_set, METH_VARARGS },
	 { (char *)"binaryprops_pbinerr_get", _wrap_binaryprops_pbinerr_get, METH_VARARGS },
	 { (char *)"binaryprops_rbinerr_set", _wrap_binaryprops_rbinerr_set, METH_VARARGS },
	 { (char *)"binaryprops_rbinerr_get", _wrap_binaryprops_rbinerr_get, METH_VARARGS },
	 { (char *)"binaryprops_zerr_set", _wrap_binaryprops_zerr_set, METH_VARARGS },
	 { (char *)"binaryprops_zerr_get", _wrap_binaryprops_zerr_get, METH_VARARGS },
	 { (char *)"binaryprops_asinicerr_set", _wrap_binaryprops_asinicerr_set, METH_VARARGS },
	 { (char *)"binaryprops_asinicerr_get", _wrap_binaryprops_asinicerr_get, METH_VARARGS },
	 { (char *)"binaryprops_rdetecterr_set", _wrap_binaryprops_rdetecterr_set, METH_VARARGS },
	 { (char *)"binaryprops_rdetecterr_get", _wrap_binaryprops_rdetecterr_get, METH_VARARGS },
	 { (char *)"binaryprops_sig_set", _wrap_binaryprops_sig_set, METH_VARARGS },
	 { (char *)"binaryprops_sig_get", _wrap_binaryprops_sig_get, METH_VARARGS },
	 { (char *)"binaryprops_phs_set", _wrap_binaryprops_phs_set, METH_VARARGS },
	 { (char *)"binaryprops_phs_get", _wrap_binaryprops_phs_get, METH_VARARGS },
	 { (char *)"binaryprops_phserr_set", _wrap_binaryprops_phserr_set, METH_VARARGS },
	 { (char *)"binaryprops_phserr_get", _wrap_binaryprops_phserr_get, METH_VARARGS },
	 { (char *)"binaryprops_cen_set", _wrap_binaryprops_cen_set, METH_VARARGS },
	 { (char *)"binaryprops_cen_get", _wrap_binaryprops_cen_get, METH_VARARGS },
	 { (char *)"binaryprops_cenerr_set", _wrap_binaryprops_cenerr_set, METH_VARARGS },
	 { (char *)"binaryprops_cenerr_get", _wrap_binaryprops_cenerr_get, METH_VARARGS },
	 { (char *)"binaryprops_pur_set", _wrap_binaryprops_pur_set, METH_VARARGS },
	 { (char *)"binaryprops_pur_get", _wrap_binaryprops_pur_get, METH_VARARGS },
	 { (char *)"binaryprops_purerr_set", _wrap_binaryprops_purerr_set, METH_VARARGS },
	 { (char *)"binaryprops_purerr_get", _wrap_binaryprops_purerr_get, METH_VARARGS },
	 { (char *)"binaryprops_pow_set", _wrap_binaryprops_pow_set, METH_VARARGS },
	 { (char *)"binaryprops_pow_get", _wrap_binaryprops_pow_get, METH_VARARGS },
	 { (char *)"binaryprops_powerr_set", _wrap_binaryprops_powerr_set, METH_VARARGS },
	 { (char *)"binaryprops_powerr_get", _wrap_binaryprops_powerr_get, METH_VARARGS },
	 { (char *)"new_binaryprops", _wrap_new_binaryprops, METH_VARARGS },
	 { (char *)"delete_binaryprops", _wrap_delete_binaryprops, METH_VARARGS },
	 { (char *)"binaryprops_swigregister", binaryprops_swigregister, METH_VARARGS },
	 { (char *)"rawbincand_full_N_set", _wrap_rawbincand_full_N_set, METH_VARARGS },
	 { (char *)"rawbincand_full_N_get", _wrap_rawbincand_full_N_get, METH_VARARGS },
	 { (char *)"rawbincand_full_T_set", _wrap_rawbincand_full_T_set, METH_VARARGS },
	 { (char *)"rawbincand_full_T_get", _wrap_rawbincand_full_T_get, METH_VARARGS },
	 { (char *)"rawbincand_full_lo_r_set", _wrap_rawbincand_full_lo_r_set, METH_VARARGS },
	 { (char *)"rawbincand_full_lo_r_get", _wrap_rawbincand_full_lo_r_get, METH_VARARGS },
	 { (char *)"rawbincand_mini_N_set", _wrap_rawbincand_mini_N_set, METH_VARARGS },
	 { (char *)"rawbincand_mini_N_get", _wrap_rawbincand_mini_N_get, METH_VARARGS },
	 { (char *)"rawbincand_mini_r_set", _wrap_rawbincand_mini_r_set, METH_VARARGS },
	 { (char *)"rawbincand_mini_r_get", _wrap_rawbincand_mini_r_get, METH_VARARGS },
	 { (char *)"rawbincand_mini_power_set", _wrap_rawbincand_mini_power_set, METH_VARARGS },
	 { (char *)"rawbincand_mini_power_get", _wrap_rawbincand_mini_power_get, METH_VARARGS },
	 { (char *)"rawbincand_mini_numsum_set", _wrap_rawbincand_mini_numsum_set, METH_VARARGS },
	 { (char *)"rawbincand_mini_numsum_get", _wrap_rawbincand_mini_numsum_get, METH_VARARGS },
	 { (char *)"rawbincand_mini_sigma_set", _wrap_rawbincand_mini_sigma_set, METH_VARARGS },
	 { (char *)"rawbincand_mini_sigma_get", _wrap_rawbincand_mini_sigma_get, METH_VARARGS },
	 { (char *)"rawbincand_psr_p_set", _wrap_rawbincand_psr_p_set, METH_VARARGS },
	 { (char *)"rawbincand_psr_p_get", _wrap_rawbincand_psr_p_get, METH_VARARGS },
	 { (char *)"rawbincand_orb_p_set", _wrap_rawbincand_orb_p_set, METH_VARARGS },
	 { (char *)"rawbincand_orb_p_get", _wrap_rawbincand_orb_p_get, METH_VARARGS },
	 { (char *)"new_rawbincand", _wrap_new_rawbincand, METH_VARARGS },
	 { (char *)"delete_rawbincand", _wrap_delete_rawbincand, METH_VARARGS },
	 { (char *)"rawbincand_swigregister", rawbincand_swigregister, METH_VARARGS },
	 { (char *)"foldstats_numdata_set", _wrap_foldstats_numdata_set, METH_VARARGS },
	 { (char *)"foldstats_numdata_get", _wrap_foldstats_numdata_get, METH_VARARGS },
	 { (char *)"foldstats_data_avg_set", _wrap_foldstats_data_avg_set, METH_VARARGS },
	 { (char *)"foldstats_data_avg_get", _wrap_foldstats_data_avg_get, METH_VARARGS },
	 { (char *)"foldstats_data_var_set", _wrap_foldstats_data_var_set, METH_VARARGS },
	 { (char *)"foldstats_data_var_get", _wrap_foldstats_data_var_get, METH_VARARGS },
	 { (char *)"foldstats_numprof_set", _wrap_foldstats_numprof_set, METH_VARARGS },
	 { (char *)"foldstats_numprof_get", _wrap_foldstats_numprof_get, METH_VARARGS },
	 { (char *)"foldstats_prof_avg_set", _wrap_foldstats_prof_avg_set, METH_VARARGS },
	 { (char *)"foldstats_prof_avg_get", _wrap_foldstats_prof_avg_get, METH_VARARGS },
	 { (char *)"foldstats_prof_var_set", _wrap_foldstats_prof_var_set, METH_VARARGS },
	 { (char *)"foldstats_prof_var_get", _wrap_foldstats_prof_var_get, METH_VARARGS },
	 { (char *)"foldstats_redchi_set", _wrap_foldstats_redchi_set, METH_VARARGS },
	 { (char *)"foldstats_redchi_get", _wrap_foldstats_redchi_get, METH_VARARGS },
	 { (char *)"new_foldstats", _wrap_new_foldstats, METH_VARARGS },
	 { (char *)"delete_foldstats", _wrap_delete_foldstats, METH_VARARGS },
	 { (char *)"foldstats_swigregister", foldstats_swigregister, METH_VARARGS },
	 { (char *)"get_psr_at_epoch", _wrap_get_psr_at_epoch, METH_VARARGS },
	 { (char *)"read_int", _wrap_read_int, METH_VARARGS },
	 { (char *)"read_double", _wrap_read_double, METH_VARARGS },
	 { (char *)"frotate", _wrap_frotate, METH_VARARGS },
	 { (char *)"drotate", _wrap_drotate, METH_VARARGS },
	 { (char *)"dorbint", _wrap_dorbint, METH_VARARGS },
	 { (char *)"keplars_eqn", _wrap_keplars_eqn, METH_VARARGS },
	 { (char *)"lin_interp_E", _wrap_lin_interp_E, METH_VARARGS },
	 { (char *)"E_to_phib", _wrap_E_to_phib, METH_VARARGS },
	 { (char *)"E_to_v", _wrap_E_to_v, METH_VARARGS },
	 { (char *)"E_to_p", _wrap_E_to_p, METH_VARARGS },
	 { (char *)"E_to_z", _wrap_E_to_z, METH_VARARGS },
	 { (char *)"E_to_phib_BT", _wrap_E_to_phib_BT, METH_VARARGS },
	 { (char *)"r_resp_halfwidth", _wrap_r_resp_halfwidth, METH_VARARGS },
	 { (char *)"z_resp_halfwidth", _wrap_z_resp_halfwidth, METH_VARARGS },
	 { (char *)"w_resp_halfwidth", _wrap_w_resp_halfwidth, METH_VARARGS },
	 { (char *)"binary_velocity", _wrap_binary_velocity, METH_VARARGS },
	 { (char *)"bin_resp_halfwidth", _wrap_bin_resp_halfwidth, METH_VARARGS },
	 { (char *)"gen_r_response", _wrap_gen_r_response, METH_VARARGS },
	 { (char *)"gen_z_response", _wrap_gen_z_response, METH_VARARGS },
	 { (char *)"gen_w_response", _wrap_gen_w_response, METH_VARARGS },
	 { (char *)"gen_bin_response", _wrap_gen_bin_response, METH_VARARGS },
	 { (char *)"get_numphotons", _wrap_get_numphotons, METH_VARARGS },
	 { (char *)"get_localpower", _wrap_get_localpower, METH_VARARGS },
	 { (char *)"get_localpower3d", _wrap_get_localpower3d, METH_VARARGS },
	 { (char *)"get_derivs3d", _wrap_get_derivs3d, METH_VARARGS },
	 { (char *)"calc_props", _wrap_calc_props, METH_VARARGS },
	 { (char *)"calc_binprops", _wrap_calc_binprops, METH_VARARGS },
	 { (char *)"calc_rzwerrs", _wrap_calc_rzwerrs, METH_VARARGS },
	 { (char *)"candidate_sigma", _wrap_candidate_sigma, METH_VARARGS },
	 { (char *)"power_for_sigma", _wrap_power_for_sigma, METH_VARARGS },
	 { (char *)"chisqr", _wrap_chisqr, METH_VARARGS },
	 { (char *)"print_candidate", _wrap_print_candidate, METH_VARARGS },
	 { (char *)"print_bin_candidate", _wrap_print_bin_candidate, METH_VARARGS },
	 { (char *)"read_rzw_cand", _wrap_read_rzw_cand, METH_VARARGS },
	 { (char *)"read_bin_cand", _wrap_read_bin_cand, METH_VARARGS },
	 { (char *)"read_rawbin_cand", _wrap_read_rawbin_cand, METH_VARARGS },
	 { (char *)"get_rzw_cand", _wrap_get_rzw_cand, METH_VARARGS },
	 { (char *)"get_bin_cand", _wrap_get_bin_cand, METH_VARARGS },
	 { (char *)"get_rawbin_cand", _wrap_get_rawbin_cand, METH_VARARGS },
	 { (char *)"chkfilelen", _wrap_chkfilelen, METH_VARARGS },
	 { (char *)"read_fcomplex_file", _wrap_read_fcomplex_file, METH_VARARGS },
	 { (char *)"read_float_file", _wrap_read_float_file, METH_VARARGS },
	 { (char *)"prune_powers", _wrap_prune_powers, METH_VARARGS },
	 { (char *)"median", _wrap_median, METH_VARARGS },
	 { (char *)"dms2rad", _wrap_dms2rad, METH_VARARGS },
	 { (char *)"hms2rad", _wrap_hms2rad, METH_VARARGS },
	 { (char *)"sphere_ang_diff", _wrap_sphere_ang_diff, METH_VARARGS },
	 { (char *)"spread_with_pad", _wrap_spread_with_pad, METH_VARARGS },
	 { (char *)"spread_no_pad", _wrap_spread_no_pad, METH_VARARGS },
	 { (char *)"paddata", _wrap_paddata, METH_VARARGS },
	 { (char *)"place_complex_kernel", _wrap_place_complex_kernel, METH_VARARGS },
	 { (char *)"place_real_kernel", _wrap_place_real_kernel, METH_VARARGS },
	 { (char *)"chop_complex_ends", _wrap_chop_complex_ends, METH_VARARGS },
	 { (char *)"chop_real_ends", _wrap_chop_real_ends, METH_VARARGS },
	 { (char *)"complex_corr_conv", _wrap_complex_corr_conv, METH_VARARGS },
	 { (char *)"real_corr_conv", _wrap_real_corr_conv, METH_VARARGS },
	 { (char *)"corr_complex", _wrap_corr_complex, METH_VARARGS },
	 { (char *)"stretch_fft", _wrap_stretch_fft, METH_VARARGS },
	 { (char *)"corr_loc_pow", _wrap_corr_loc_pow, METH_VARARGS },
	 { (char *)"rz_interp", _wrap_rz_interp, METH_VARARGS },
	 { (char *)"max_r_arr", _wrap_max_r_arr, METH_VARARGS },
	 { (char *)"max_rz_arr", _wrap_max_rz_arr, METH_VARARGS },
	 { (char *)"fold_errors", _wrap_fold_errors, METH_VARARGS },
	 { (char *)"foldfile", _wrap_foldfile, METH_VARARGS },
	 { (char *)"fold", _wrap_fold, METH_VARARGS },
	 { (char *)"simplefold", _wrap_simplefold, METH_VARARGS },
	 { (char *)"doppler", _wrap_doppler, METH_VARARGS },
	 { (char *)"search_minifft", _wrap_search_minifft, METH_VARARGS },
	 { (char *)"print_rawbincand", _wrap_print_rawbincand, METH_VARARGS },
	 { (char *)"barycenter", _wrap_barycenter, METH_VARARGS },
	 { (char *)"fftwcall", _wrap_fftwcall, METH_VARARGS },
	 { (char *)"tablesixstepfft", _wrap_tablesixstepfft, METH_VARARGS },
	 { (char *)"realfft", _wrap_realfft, METH_VARARGS },
	 { (char *)"tree_max_dm", _wrap_tree_max_dm, METH_VARARGS },
	 { (char *)"smearing_from_bw", _wrap_smearing_from_bw, METH_VARARGS },
	 { (char *)"delay_from_dm", _wrap_delay_from_dm, METH_VARARGS },
	 { (char *)"dm_from_delay", _wrap_dm_from_delay, METH_VARARGS },
	 { (char *)"dedisp_delays", _wrap_dedisp_delays, METH_VARARGS },
	 { (char *)"subband_search_delays", _wrap_subband_search_delays, METH_VARARGS },
	 { (char *)"subband_delays", _wrap_subband_delays, METH_VARARGS },
	 { (char *)"nice_output_1", _wrap_nice_output_1, METH_VARARGS },
	 { (char *)"nice_output_2", _wrap_nice_output_2, METH_VARARGS },
	 { (char *)"corr_rz_plane", _wrap_corr_rz_plane, METH_VARARGS },
	 { (char *)"corr_rz_interp", _wrap_corr_rz_interp, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_psrparams[] = {{"_p_psrparams", 0, "psrparams *", 0},{"_p_psrparams"},{0}};
static swig_type_info _swigt__p_orbitparams[] = {{"_p_orbitparams", 0, "orbitparams *", 0},{"_p_orbitparams"},{0}};
static swig_type_info _swigt__p_binaryprops[] = {{"_p_binaryprops", 0, "binaryprops *", 0},{"_p_binaryprops"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0},{"_p_double"},{0}};
static swig_type_info _swigt__p_makedata[] = {{"_p_makedata", 0, "makedata *", 0},{"_p_makedata"},{0}};
static swig_type_info _swigt__p_dcomplex[] = {{"_p_dcomplex", 0, "dcomplex *", 0},{"_p_dcomplex"},{0}};
static swig_type_info _swigt__p_fcomplex[] = {{"_p_fcomplex", 0, "fcomplex *", 0},{"_p_fcomplex"},{0}};
static swig_type_info _swigt__p_rderivs[] = {{"_p_rderivs", 0, "rderivs *", 0},{"_p_rderivs"},{0}};
static swig_type_info _swigt__p_float[] = {{"_p_float", 0, "float *", 0},{"_p_float"},{0}};
static swig_type_info _swigt__p_DoubleArray[] = {{"_p_DoubleArray", 0, "DoubleArray *", 0},{"_p_DoubleArray"},{0}};
static swig_type_info _swigt__p_rzwerrs[] = {{"_p_rzwerrs", 0, "rzwerrs *", 0},{"_p_rzwerrs"},{0}};
static swig_type_info _swigt__p_rawbincand[] = {{"_p_rawbincand", 0, "rawbincand *", 0},{"_p_rawbincand"},{0}};
static swig_type_info _swigt__p_fourierprops[] = {{"_p_fourierprops", 0, "fourierprops *", 0},{"_p_fourierprops"},{0}};
static swig_type_info _swigt__p_FILE[] = {{"_p_FILE", 0, "FILE *", 0},{"_p_FILE"},{0}};
static swig_type_info _swigt__p_infodata[] = {{"_p_infodata", 0, "infodata *", 0},{"_p_infodata"},{0}};
static swig_type_info _swigt__p_foldstats[] = {{"_p_foldstats", 0, "foldstats *", 0},{"_p_foldstats"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0},{"_p_int"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_psrparams, 
_swigt__p_orbitparams, 
_swigt__p_binaryprops, 
_swigt__p_double, 
_swigt__p_makedata, 
_swigt__p_dcomplex, 
_swigt__p_fcomplex, 
_swigt__p_rderivs, 
_swigt__p_float, 
_swigt__p_DoubleArray, 
_swigt__p_rzwerrs, 
_swigt__p_rawbincand, 
_swigt__p_fourierprops, 
_swigt__p_FILE, 
_swigt__p_infodata, 
_swigt__p_foldstats, 
_swigt__p_int, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_FLOAT,   (char*)"SQRT2", 0, (double) 1.4142135623730950488016887242096980785696718753769, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"PI", 0, (double) 3.1415926535897932384626433832795028841971693993751, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"TWOPI", 0, (double) 6.2831853071795864769252867665590057683943387987502, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"DEGTORAD", 0, (double) 0.017453292519943295769236907684886127134428718885417, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"RADTODEG", 0, (double) 57.29577951308232087679815481410517033240547246656, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"PIBYTWO", 0, (double) 1.5707963267948966192313216916397514420985846996876, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"SOL", 0, (double) 299792458.0, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"SECPERJULYR", 0, (double) 31557600.0, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"SECPERDAY", 0, (double) 86400.0, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"ARCSEC2RAD", 0, (double) 4.8481368110953599358991410235794797595635330237270e-6, 0, 0},
{ SWIG_PY_FLOAT,   (char*)"SEC2RAD", 0, (double) 7.2722052166430399038487115353692196393452995355905e-5, 0, 0},
{ SWIG_PY_INT,     (char *)"LOWACC", (long) LOWACC, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"HIGHACC", (long) HIGHACC, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTERBIN", (long) INTERBIN, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTERPOLATE", (long) INTERPOLATE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NO_CHECK_ALIASED", (long) NO_CHECK_ALIASED, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"CHECK_ALIASED", (long) CHECK_ALIASED, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"CONV", (long) CONV, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"CORR", (long) CORR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INPLACE_CONV", (long) INPLACE_CONV, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INPLACE_CORR", (long) INPLACE_CORR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"FFTDK", (long) FFTDK, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"FFTD", (long) FFTD, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"FFTK", (long) FFTK, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NOFFTS", (long) NOFFTS, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"RAW", (long) RAW, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PREPPED", (long) PREPPED, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"FFT", (long) FFT, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SAME", (long) SAME, 0, 0, 0},
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    import_array();
    
}

