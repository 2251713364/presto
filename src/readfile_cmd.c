/*****
  command line parser -- generated by clig (Version: 1.0.1)

  The command line parser `clig':
  (C) 1995 Harald Kirsch (kir@iitb.fhg.de)
*****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* mainly a hack to make things work on SUNOS with gcc */
extern double strtod(const char *, char **);
extern long int strtol(const char *, char **, int);

#include "readfile_cmd.h"

char *Program;

/*@-null*/
static int indexDefault[] = {0, -1};

static Cmdline cmd = {
  /***** -more: Paginate the output like 'more' */
  /* moreP = */ FALSE,
  /***** -float: Raw data in floating point format */
  /* fltP = */ FALSE,
  /***** -f: Raw data in floating point format */
  /* sfltP = */ FALSE,
  /***** -double: Raw data in double precision format */
  /* dblP = */ FALSE,
  /***** -d: Raw data in double precision format */
  /* sdblP = */ FALSE,
  /***** -fcomplex: Raw data in float-complex format */
  /* fcxP = */ FALSE,
  /***** -fc: Raw data in float-complex format */
  /* sfcxP = */ FALSE,
  /***** -dcomplex: Raw data in double-complex format */
  /* dcxP = */ FALSE,
  /***** -dc: Raw data in double-complex format */
  /* sdcxP = */ FALSE,
  /***** -int: Raw data in integer format */
  /* igrP = */ FALSE,
  /***** -i: Raw data in integer format */
  /* sigrP = */ FALSE,
  /***** -long: Raw data in long format */
  /* lngP = */ FALSE,
  /***** -l: Raw data in long format */
  /* slngP = */ FALSE,
  /***** -rzwcand: Raw data in rzw search candidate format */
  /* rzwP = */ FALSE,
  /***** -rzw: Raw data in rzw search candidate format */
  /* srzwP = */ FALSE,
  /***** -bincand: Raw data in bin search candidate format */
  /* binP = */ FALSE,
  /***** -bin: Raw data in bin search candidate format */
  /* sbinP = */ FALSE,
  /***** -pkmb: Raw data in Parkes Multibeam format */
  /* pksP = */ FALSE,
  /***** -pk: Raw data in Parkes Multibeam format */
  /* spksP = */ FALSE,
  /***** -index: The range of objects to display */
  /* indexP = */ TRUE,
  /* index = */ indexDefault,
  /* indexC = */ 2,
  /***** -nph: 0th FFT bin amplitude (for 'RZW' data) */
  /* nphP = */ TRUE,
  /* nph = */ 1.0,
  /* nphC = */ 1,
  /***** uninterpreted rest of command line */
  /* argc = */ 0,
  /* argv = */ (char**)0,
  /***** the original command line concatenated */
  /* full_cmd_line = */ NULL
};

/*@=null*/

/***** let LCLint run more smoothly */
/*@-predboolothers*/
/*@-boolops*/


/**********************************************************************/
int
getIntOpt(int argc, char **argv, int i, int *value, int force)
{
  char *end;

  if( ++i>=argc ) goto nothingFound;

  *value = (int)strtol(argv[i], &end, 10);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace(*end) ) end+=1;
  if( *end ) goto nothingFound;

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr, 
	  "%s: missing or malformed integer value after option `%s'\n",
	  Program, argv[i-1]);
    exit(EXIT_FAILURE);
}
/**********************************************************************/
int
getIntOpts(int argc, char **argv, int i, 
	   int **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = (int*)calloc((size_t)alloced, sizeof(int));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(int));
      if( !*values ) goto outMem;
    }

    (*values)[used] = (int)strtol(argv[used+i+1], &end, 10);

    /***** check for conversion error */
    if( end==argv[used+i+1] ) break;

    /***** check for surplus non-whitespace */
    while( isspace(*end) ) end+=1;
    if( *end ) break;
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be an "
	    "integer value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/
int
getdoubleOpt(int argc, char **argv, int i, double *value, int force)
{
  char *end;

  if( ++i>=argc ) goto nothingFound;

  *value = (double)strtod(argv[i], &end);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace(*end) ) end+=1;
  if( *end ) goto nothingFound;

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr,
	  "%s: missing or malformed double value after option `%s'\n",
	  Program, argv[i-1]);
  exit(EXIT_FAILURE);
 
}
/**********************************************************************/
int
getdoubleOpts(int argc, char **argv, int i, 
	   double **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values.
  *****/
  alloced = cmin + 4;
  *values = (double*)calloc((size_t)alloced, sizeof(double));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(double));
      if( !*values ) goto outMem;
    }

    (*values)[used] = (double)strtod(argv[used+i+1], &end);

    /***** check for conversion error */
    if( end==argv[used+i+1] ) break;

    /***** check for surplus non-whitespace */
    while( isspace(*end) ) end+=1;
    if( *end ) break;
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be a "
	    "double value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/
int
getStringOpt(int argc, char **argv, int i, char **value, int force)
{
  if( ++i>=argc ) {
    fprintf(stderr, "%s: missing string after option `%s'\n",
            Program, argv[i-1]);
    exit(EXIT_FAILURE);
  }
  
  if( !force && argv[i+1][0] == '-' ) return i-1;
  *value = argv[i];
  return i;
}
/**********************************************************************/
int
getStringOpts(int argc, char **argv, int i, 
	   char*  **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  alloced = cmin + 4;
    
  *values = (char**)calloc((size_t)alloced, sizeof(char*));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory during parsing of option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(char*));
      if( !*values ) goto outMem;
    }

    if( argv[used+i+1][0]=='-' ) break;
    (*values)[used] = argv[used+i+1];
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
    "%s: less than %d parameters for option `%s', only %d found\n",
	    Program, cmin, argv[i], used);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/
void
checkIntLower(char *opt, int *values, int count, int max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%d\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
void
checkIntHigher(char *opt, int *values, int count, int min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%d\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
void
checkdoubleLower(char *opt, double *values, int count, double max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%f\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
void
checkdoubleHigher(char *opt, double *values, int count, double min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%f\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
static char *
catArgv(int argc, char **argv)
{
  int i;
  size_t l;
  char *s, *t;

  for(i=0, l=0; i<argc; i++) l += (1+strlen(argv[i]));
  s = malloc(l);
  if( !s ) {
    fprintf(stderr, "%s: out of memory\n", Program);
    exit(EXIT_FAILURE);
  }
  strcpy(s, argv[0]);
  t = s;
  for(i=1; i<argc; i++) {
    t = t+strlen(t);
    *t++ = ' ';
    strcpy(t, argv[i]);
  }
  return s;
}
/**********************************************************************/
void
showOptionValues(void)
{
  int i;

  printf("Full command line is:\n`%s'\n", cmd.full_cmd_line);

  /***** -more: Paginate the output like 'more' */
  if( !cmd.moreP ) {
    printf("-more not found.\n");
  } else {
    printf("-more found:\n");
  }

  /***** -float: Raw data in floating point format */
  if( !cmd.fltP ) {
    printf("-float not found.\n");
  } else {
    printf("-float found:\n");
  }

  /***** -f: Raw data in floating point format */
  if( !cmd.sfltP ) {
    printf("-f not found.\n");
  } else {
    printf("-f found:\n");
  }

  /***** -double: Raw data in double precision format */
  if( !cmd.dblP ) {
    printf("-double not found.\n");
  } else {
    printf("-double found:\n");
  }

  /***** -d: Raw data in double precision format */
  if( !cmd.sdblP ) {
    printf("-d not found.\n");
  } else {
    printf("-d found:\n");
  }

  /***** -fcomplex: Raw data in float-complex format */
  if( !cmd.fcxP ) {
    printf("-fcomplex not found.\n");
  } else {
    printf("-fcomplex found:\n");
  }

  /***** -fc: Raw data in float-complex format */
  if( !cmd.sfcxP ) {
    printf("-fc not found.\n");
  } else {
    printf("-fc found:\n");
  }

  /***** -dcomplex: Raw data in double-complex format */
  if( !cmd.dcxP ) {
    printf("-dcomplex not found.\n");
  } else {
    printf("-dcomplex found:\n");
  }

  /***** -dc: Raw data in double-complex format */
  if( !cmd.sdcxP ) {
    printf("-dc not found.\n");
  } else {
    printf("-dc found:\n");
  }

  /***** -int: Raw data in integer format */
  if( !cmd.igrP ) {
    printf("-int not found.\n");
  } else {
    printf("-int found:\n");
  }

  /***** -i: Raw data in integer format */
  if( !cmd.sigrP ) {
    printf("-i not found.\n");
  } else {
    printf("-i found:\n");
  }

  /***** -long: Raw data in long format */
  if( !cmd.lngP ) {
    printf("-long not found.\n");
  } else {
    printf("-long found:\n");
  }

  /***** -l: Raw data in long format */
  if( !cmd.slngP ) {
    printf("-l not found.\n");
  } else {
    printf("-l found:\n");
  }

  /***** -rzwcand: Raw data in rzw search candidate format */
  if( !cmd.rzwP ) {
    printf("-rzwcand not found.\n");
  } else {
    printf("-rzwcand found:\n");
  }

  /***** -rzw: Raw data in rzw search candidate format */
  if( !cmd.srzwP ) {
    printf("-rzw not found.\n");
  } else {
    printf("-rzw found:\n");
  }

  /***** -bincand: Raw data in bin search candidate format */
  if( !cmd.binP ) {
    printf("-bincand not found.\n");
  } else {
    printf("-bincand found:\n");
  }

  /***** -bin: Raw data in bin search candidate format */
  if( !cmd.sbinP ) {
    printf("-bin not found.\n");
  } else {
    printf("-bin found:\n");
  }

  /***** -pkmb: Raw data in Parkes Multibeam format */
  if( !cmd.pksP ) {
    printf("-pkmb not found.\n");
  } else {
    printf("-pkmb found:\n");
  }

  /***** -pk: Raw data in Parkes Multibeam format */
  if( !cmd.spksP ) {
    printf("-pk not found.\n");
  } else {
    printf("-pk found:\n");
  }

  /***** -index: The range of objects to display */
  if( !cmd.indexP ) {
    printf("-index not found.\n");
  } else {
    printf("-index found:\n");
    if( !cmd.indexC ) {
      printf("  no values\n");
    } else {
      printf("  values =");
      for(i=0; i<cmd.indexC; i++) {
        printf(" `%d'", cmd.index[i]);
      }
      printf("\n");
    }
  }

  /***** -nph: 0th FFT bin amplitude (for 'RZW' data) */
  if( !cmd.nphP ) {
    printf("-nph not found.\n");
  } else {
    printf("-nph found:\n");
    if( !cmd.nphC ) {
      printf("  no values\n");
    } else {
      printf("  value = `%f'\n", cmd.nph);
    }
  }
  if( !cmd.argc ) {
    printf("no remaining parameters in argv\n");
  } else {
    printf("argv =");
    for(i=0; i<cmd.argc; i++) {
      printf(" `%s'", cmd.argv[i]);
    }
    printf("\n");
  }
}
/**********************************************************************/

void
usage(void)
{
  fprintf(stderr, "usage: %s%s", Program, "\
 [-more] [-float] [-f] [-double] [-d] [-fcomplex] [-fc] [-dcomplex] [-dc] [-int] [-i] [-long] [-l] [-rzwcand] [-rzw] [-bincand] [-bin] [-pkmb] [-pk] [-index [index]] [-nph nph] file\n\
    Reads raw data from a binary file and displays it on stdout.\n\
      -more: Paginate the output like 'more'\n\
     -float: Raw data in floating point format\n\
         -f: Raw data in floating point format\n\
    -double: Raw data in double precision format\n\
         -d: Raw data in double precision format\n\
  -fcomplex: Raw data in float-complex format\n\
        -fc: Raw data in float-complex format\n\
  -dcomplex: Raw data in double-complex format\n\
        -dc: Raw data in double-complex format\n\
       -int: Raw data in integer format\n\
         -i: Raw data in integer format\n\
      -long: Raw data in long format\n\
         -l: Raw data in long format\n\
   -rzwcand: Raw data in rzw search candidate format\n\
       -rzw: Raw data in rzw search candidate format\n\
   -bincand: Raw data in bin search candidate format\n\
       -bin: Raw data in bin search candidate format\n\
      -pkmb: Raw data in Parkes Multibeam format\n\
        -pk: Raw data in Parkes Multibeam format\n\
     -index: The range of objects to display\n\
             0...2 integer values between -1 and oo\n\
             default: `0' `-1'\n\
       -nph: 0th FFT bin amplitude (for 'RZW' data)\n\
             1 double precision value\n\
             default: `1.0'\n\
       file: Input data file name.\n\
             1 string value\n\
version: 20Mar99\n\
");
  exit(EXIT_FAILURE);
}
/**********************************************************************/
Cmdline *
parseCmdline(int argc, char **argv)
{
  int i, keep;

  Program = argv[0];
  cmd.full_cmd_line = catArgv(argc, argv);
  for(i=1, cmd.argc=1; i<argc; i++) {
    if( 0==strcmp("--", argv[i]) ) {
      while( ++i<argc ) argv[cmd.argc++] = argv[i];
      continue;
    }

    if( 0==strcmp("-more", argv[i]) ) {
      cmd.moreP = TRUE;
      continue;
    }

    if( 0==strcmp("-float", argv[i]) ) {
      cmd.fltP = TRUE;
      continue;
    }

    if( 0==strcmp("-f", argv[i]) ) {
      cmd.sfltP = TRUE;
      continue;
    }

    if( 0==strcmp("-double", argv[i]) ) {
      cmd.dblP = TRUE;
      continue;
    }

    if( 0==strcmp("-d", argv[i]) ) {
      cmd.sdblP = TRUE;
      continue;
    }

    if( 0==strcmp("-fcomplex", argv[i]) ) {
      cmd.fcxP = TRUE;
      continue;
    }

    if( 0==strcmp("-fc", argv[i]) ) {
      cmd.sfcxP = TRUE;
      continue;
    }

    if( 0==strcmp("-dcomplex", argv[i]) ) {
      cmd.dcxP = TRUE;
      continue;
    }

    if( 0==strcmp("-dc", argv[i]) ) {
      cmd.sdcxP = TRUE;
      continue;
    }

    if( 0==strcmp("-int", argv[i]) ) {
      cmd.igrP = TRUE;
      continue;
    }

    if( 0==strcmp("-i", argv[i]) ) {
      cmd.sigrP = TRUE;
      continue;
    }

    if( 0==strcmp("-long", argv[i]) ) {
      cmd.lngP = TRUE;
      continue;
    }

    if( 0==strcmp("-l", argv[i]) ) {
      cmd.slngP = TRUE;
      continue;
    }

    if( 0==strcmp("-rzwcand", argv[i]) ) {
      cmd.rzwP = TRUE;
      continue;
    }

    if( 0==strcmp("-rzw", argv[i]) ) {
      cmd.srzwP = TRUE;
      continue;
    }

    if( 0==strcmp("-bincand", argv[i]) ) {
      cmd.binP = TRUE;
      continue;
    }

    if( 0==strcmp("-bin", argv[i]) ) {
      cmd.sbinP = TRUE;
      continue;
    }

    if( 0==strcmp("-pkmb", argv[i]) ) {
      cmd.pksP = TRUE;
      continue;
    }

    if( 0==strcmp("-pk", argv[i]) ) {
      cmd.spksP = TRUE;
      continue;
    }

    if( 0==strcmp("-index", argv[i]) ) {
      cmd.indexP = TRUE;
      keep = i;
      i = getIntOpts(argc, argv, i, &cmd.index, 0, 2);
      cmd.indexC = i-keep;
      checkIntHigher("-index", cmd.index, cmd.indexC, -1);
      continue;
    }

    if( 0==strcmp("-nph", argv[i]) ) {
      cmd.nphP = TRUE;
      keep = i;
      i = getdoubleOpt(argc, argv, i, &cmd.nph, 1);
      cmd.nphC = i-keep;
      continue;
    }

    if( argv[i][0]=='-' ) {
      fprintf(stderr, "\n%s: unknown option `%s'\n\n",
              Program, argv[i]);
      usage();
    }
    argv[cmd.argc++] = argv[i];
  }/* for i */


  /*@-mustfree*/
  cmd.argv = argv+1;
  /*@=mustfree*/
  cmd.argc -= 1;

  if( 1>cmd.argc ) {
    fprintf(stderr, "%s: there should be at least 1 non-option argument(s)\n",
            Program);
    exit(EXIT_FAILURE);
  }
  if( 1<cmd.argc ) {
    fprintf(stderr, "%s: there should be at most 1 non-option argument(s)\n",
            Program);
    exit(EXIT_FAILURE);
  }
  /*@-compmempass*/  return &cmd;
}

